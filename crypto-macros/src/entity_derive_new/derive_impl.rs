use itertools::Itertools as _;
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{Ident, Lifetime};

use crate::entity_derive_new::{Entity, column_type::ColumnType};

impl quote::ToTokens for Entity {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.extend(self.impl_entity_base());
        tokens.extend(self.impl_entity_generic());
        tokens.extend(self.impl_entity_wasm());
        tokens.extend(self.impl_borrow_primary_key());
        tokens.extend(self.impl_entity_database_mutation());
        tokens.extend(self.impl_entity_delete_borrowed());
        tokens.extend(self.impl_decrypting());
        tokens.extend(self.impl_encrypting());
    }
}

impl Entity {
    /// `impl EntityBase for MyEntity`
    fn impl_entity_base(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            ..
        } = self;

        // Identical for both wasm and non-wasm
        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl crate::traits::EntityBase for #struct_name {
                type ConnectionType = crate::connection::KeystoreDatabaseConnection;
                type AutoGeneratedFields = ();
                const COLLECTION_NAME: &'static str = #collection_name;

                fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
                    crate::transaction::dynamic_dispatch::Entity::#struct_name(self)
                }
            }
        }
    }

    /// `#[cfg(not(target_family = "wasm"))] impl Entity for MyEntity`
    fn impl_entity_generic(&self) -> TokenStream {
        let Self {
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let primary_key = id_column.column_type.owned();
        let id_field_name = &id_column.field_name;

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        quote! {
            #[cfg(not(target_family = "wasm"))]
            #[::async_trait::async_trait]
            impl crate::traits::Entity for #struct_name {
                type PrimaryKey = #primary_key;

                fn primary_key(&self) -> #primary_key {
                    self.#id_field_name.clone()
                }

                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    <Self as crate::traits::BorrowPrimaryKey>::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    crate::entities::platform::count_helper::<Self>(conn).await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    crate::entities::platform::load_all_helper::<Self, _>(conn, |row| {
                        Ok(Self {
                            #( #field_assignments, )*
                        })
                    }).await
                }
            }
        }
    }

    /// `#[cfg(target_family = "wasm")] impl Entity for MyEntity`
    fn impl_entity_wasm(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            ..
        } = self;

        let primary_key = id_column.column_type.owned();
        let id_field_name = &id_column.field_name;

        quote! {
            #[cfg(target_family = "wasm")]
            #[::async_trait::async_trait(?Send)]
            impl crate::traits::Entity for #struct_name {
                type PrimaryKey = #primary_key;

                fn primary_key(&self) -> #primary_key {
                    self.#id_field_name.clone()
                }

                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    Self::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    conn.storage().count(#collection_name).await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    conn.storage().get_all(#collection_name).await
                }
            }
        }
    }

    /// `impl BorrowPrimaryKey for MyEntity`
    fn impl_borrow_primary_key(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let borrowed_primary_key = id_column.column_type.borrowed();
        let pk_field_name = &id_column.field_name;
        let pk_column_name = id_column
            .column_name
            .clone()
            .unwrap_or_else(|| id_column.field_name.to_string());

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        quote! {
            #[cfg_attr(target_family = "wasm", ::async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), ::async_trait::async_trait)]
            impl crate::traits::BorrowPrimaryKey for #struct_name {
                type BorrowedPrimaryKey = #borrowed_primary_key;

                fn borrow_primary_key(&self) -> &Self::BorrowedPrimaryKey {
                    &self.#pk_field_name
                }

                async fn get_borrowed<Q>(conn: &mut Self::ConnectionType, key: &Q) -> crate::CryptoKeystoreResult<Option<Self>>
                where
                    Self::PrimaryKey: std::borrow::Borrow<Q>,
                    Q: crate::traits::KeyType,
                {
                    #[cfg(target_family = "wasm")]
                    {
                        conn.storage().get(#collection_name, key.bytes().as_ref()).await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::get_helper::<Self, _>(conn, #pk_column_name, key.bytes().as_ref(), |row| {
                            Ok(Self {
                                #( #field_assignments, )*
                            })
                        }).await
                    }
                }
            }
        }
    }

    fn impl_entity_database_mutation(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let sql_column_names = std::iter::once(id_column.sql_name())
            .chain(other_columns.iter().map(|column| column.sql_name()))
            .join(", ");
        let sql_field_placeholders = std::iter::repeat_n("?", other_columns.len() + 1).join(", ");
        let sql_statement =
            format!("INSERT OR REPLACE INTO {collection_name} ({sql_column_names}) VALUES ({sql_field_placeholders})");
        let fields = std::iter::once(id_column.store_expression())
            .chain(other_columns.iter().map(|column| column.store_expression()))
            .map(|tokens| quote!(#tokens,))
            .collect::<TokenStream>();

        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl<'a> crate::traits::EntityDatabaseMutation<'a> for #struct_name {
                type Transaction = crate::connection::TransactionWrapper<'a>;

                async fn save(&'a self, tx: &Self::Transaction) -> crate::CryptoKeystoreResult<()> {
                    #[cfg(target_family = "wasm")]
                        {
                            // TODO(WPB-22196): don't clone here, we don't need mutable ownership to save
                            tx.save(self.clone()).await
                        }

                        #[cfg(not(target_family = "wasm"))]
                        {
                            let mut stmt = tx.prepare_cached(#sql_statement)?;
                            stmt.execute(rusqlite::params![#fields])?;
                            Ok(())
                        }
                }

                async fn count(tx: &Self::Transaction) -> crate::CryptoKeystoreResult<u32> {
                    #[cfg(target_family = "wasm")]
                    {
                        tx.count::<Self>().await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::count_helper_tx::<Self>(tx).await
                    }
                }

                async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<bool> {
                    <Self as crate::traits::EntityDeleteBorrowed>::delete_borrowed(tx, id).await
                }
            }
        }
    }

    fn impl_entity_delete_borrowed(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            ..
        } = self;

        let id_column_name = id_column.sql_name();

        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl<'a> crate::traits::EntityDeleteBorrowed<'a> for #struct_name {
                async fn delete_borrowed<Q>(
                    tx: &<Self as crate::traits::EntityDatabaseMutation<'a>>::Transaction,
                    id: &Q,
                ) -> crate::CryptoKeystoreResult<bool>
                where
                    Self::PrimaryKey: std::borrow::Borrow<Q>,
                    Q: crate::traits::KeyType
                {
                    #[cfg(target_family = "wasm")]
                    {
                        tx.delete(#collection_name, id.bytes().as_ref()).await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::delete_helper::<Self>(tx, #id_column_name, id.bytes().as_ref()).await
                    }
                }
            }
        }
    }

    fn impl_decrypting(&self) -> TokenStream {
        let Self {
            visibility,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let decrypt_struct_name = Ident::new(&format!("{struct_name}Decrypt"), Span::call_site());
        let lifetime = Lifetime::new("'a", Span::call_site());
        let field_name =
            std::iter::once(&id_column.field_name).chain(other_columns.iter().map(|column| &column.field_name));
        let field_type = std::iter::once(id_column.column_type.owned()).chain(
            other_columns
                .iter()
                .map(|column| column.column_type.encrypted_form().borrowed_with_sigil(&lifetime)),
        );

        let id_field_name = &id_column.field_name;
        // id field gets moved: no cloning!
        let id_field_assignment = quote!(#id_field_name: self.#id_field_name);

        let other_field_assignment = other_columns.iter().map(|column| {
            let field_name = &column.field_name;
            let make_decrypt_operation = |accessor: TokenStream| {
                quote!(
                    <#struct_name as crate::traits::DecryptData>::decrypt_data(
                        cipher,
                        &self.#id_field_name,
                        #accessor,
                    )
                )
            };
            let field_expr = match column.column_type {
                ColumnType::Bytes => {
                    let decrypt_operation = make_decrypt_operation(quote!(self.#field_name));
                    quote!(#decrypt_operation?)
                }
                ColumnType::String => {
                    let decrypt_operation = make_decrypt_operation(quote!(self.#field_name));
                    quote!(String::from_utf8(#decrypt_operation?).map_err(|err| err.utf8_error())?)
                }
                ColumnType::OptionalBytes => {
                    let decrypt_operation = make_decrypt_operation(quote!(#field_name));
                    quote!(self.#field_name.map(|#field_name| #decrypt_operation).transpose()?)
                }
            };

            quote!(#field_name: #field_expr)
        });

        // id field gets moved _last_ so that we can borrow `self.id_field` for the `decrypt_data` calls
        let field_assignment = other_field_assignment.chain(std::iter::once(id_field_assignment));

        quote! {
            #[derive(serde::Deserialize)]
            #visibility struct #decrypt_struct_name<#lifetime> {
                // we need this phantom data to ensure the lifetime is _always_ used;
                // this produces an error otherwise
                #[serde(skip)]
                _phantom_data: std::marker::PhantomData<&#lifetime ()>,
                #( #field_name: #field_type, )*
            }

            impl<#lifetime> crate::traits::Decrypting<#lifetime> for #decrypt_struct_name<#lifetime> {
                type DecryptedForm = #struct_name;

                fn decrypt(self, cipher: &aes_gcm::Aes256Gcm) -> crate::CryptoKeystoreResult<#struct_name> {
                    Ok(#struct_name {
                        #( #field_assignment, )*
                    })
                }
            }

            impl<#lifetime> crate::traits::Decryptable<#lifetime> for #struct_name {
                type DecryptableFrom = #decrypt_struct_name<#lifetime>;
            }
        }
    }

    fn impl_encrypting(&self) -> TokenStream {
        let Self {
            visibility,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let encrypt_struct_name = Ident::new(&format!("{struct_name}Encrypt"), Span::call_site());
        let lifetime = Lifetime::new("'a", Span::call_site());
        let field_name =
            std::iter::once(&id_column.field_name).chain(other_columns.iter().map(|column| &column.field_name));
        let field_type = std::iter::once(id_column.column_type.borrowed_with_sigil(&lifetime)).chain(
            other_columns
                .iter()
                .map(|column| column.column_type.encrypted_form().owned()),
        );

        let id_field_name = &id_column.field_name;
        let id_field_assignment = quote!(#id_field_name: &self.#id_field_name);

        let other_field_assignment = other_columns.iter().map(|column| {
            let field_name = &column.field_name;
            let make_encrypt_operation = |accessor: TokenStream| {
                quote!(
                    self.encrypt_data(
                        cipher,
                        #accessor,
                    )
                )
            };
            let field_expr = match column.column_type {
                ColumnType::Bytes => {
                    let encrypt_operation = make_encrypt_operation(quote!(&self.#field_name));
                    quote!(#encrypt_operation?)
                }
                ColumnType::String => {
                    let encrypt_operation = make_encrypt_operation(quote!(self.#field_name.as_bytes()));
                    quote!(#encrypt_operation?)
                }
                ColumnType::OptionalBytes => {
                    let encrypt_operation = make_encrypt_operation(quote!(#field_name));
                    quote!(self.#field_name.as_ref().map(|#field_name| #encrypt_operation).transpose()?)
                }
            };

            quote!(#field_name: #field_expr)
        });

        let field_assignment = std::iter::once(id_field_assignment).chain(other_field_assignment);

        quote! {
            #[derive(serde::Serialize)]
            #visibility struct #encrypt_struct_name<#lifetime> {
                #( #field_name: #field_type, )*
            }

            impl<#lifetime> crate::traits::Encrypting<#lifetime> for #struct_name {
                type EncryptedForm = #encrypt_struct_name<#lifetime>;

                fn encrypt(&#lifetime self, cipher: &aes_gcm::Aes256Gcm) -> crate::CryptoKeystoreResult<#encrypt_struct_name> {
                    use crate::traits::EncryptData as _;
                    Ok(#encrypt_struct_name {
                        #( #field_assignment, )*
                    })
                }
            }
        }
    }
}

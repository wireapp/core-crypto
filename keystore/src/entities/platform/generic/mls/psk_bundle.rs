use std::borrow::Borrow;

use async_trait::async_trait;
use rusqlite::{Row, ToSql};

use crate::{
    CryptoKeystoreResult, Entity, EntityBase, EntityGetBorrowed, EntityTransactionDeleteBorrowed, EntityTransactionExt,
    KeyType,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::{
        StoredPskBundle,
        platform::generic::{count_helper, count_helper_tx, delete_helper, get_helper, load_all_helper},
    },
};

impl StoredPskBundle {
    fn from_row(row: &Row<'_>) -> rusqlite::Result<Self> {
        let psk_id = row.get("psk_id")?;
        let psk = row.get("psk")?;
        Ok(Self { psk_id, psk })
    }
}

#[async_trait]
impl EntityBase for StoredPskBundle {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "mls_psk_bundles";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::PskBundle(self)
    }
}

#[async_trait]
impl Entity for StoredPskBundle {
    type PrimaryKey = Vec<u8>;

    /// Get this entity's primary key.
    fn primary_key(&self) -> Self::PrimaryKey {
        self.psk_id.clone()
    }

    /// Get an entity by its primary key.
    ///
    /// For entites whose primary key has a distinct borrowed type, it is best to implement this as a direct passthrough:
    ///
    /// ```rust,ignore
    /// async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CoreCryptoKeystoreResult<Option<Self>> {
    ///     <Self as EntityGetBorrowed>::get_borrowed(conn, key).await
    /// }
    /// ```
    async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CryptoKeystoreResult<Option<Self>> {
        <Self as EntityGetBorrowed>::get_borrowed(conn, key).await
    }

    /// Count the number of entities of this type in the database.
    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        count_helper::<Self>(conn).await
    }

    /// Retrieve all entities of this type from the database.
    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        load_all_helper(conn, Self::from_row).await
    }
}

#[async_trait]
impl EntityGetBorrowed for StoredPskBundle {
    /// Get an entity by a borrowed form of its primary key.
    ///
    /// The type signature here is somewhat complicated, but it breaks down simply: if our primary key is something
    /// like `Vec<u8>`, we want to be able to use this method even if what we have on hand is `&[u8]`.
    async fn get_borrowed<Q>(conn: &mut Self::ConnectionType, key: &Q) -> CryptoKeystoreResult<Option<Self>>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        let key_hash = crate::sha256(key.bytes().as_ref());
        get_helper(conn, "id_sha256", key_hash, Self::from_row).await
    }
}

#[async_trait]
impl<'a> EntityTransactionExt<'a> for StoredPskBundle {
    type Transaction = TransactionWrapper<'a>;

    /// Use the transaction's interface to save this entity to the database
    async fn save(&self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        // Use UPSERT (ON CONFLICT DO UPDATE)
        let mut statement = tx.prepare_cached(
            "INSERT INTO mls_psk_bundles (id_sha256, psk_id, psk)
            VALUES (?, ?, ?)
            ON CONFLICT(id_sha256) DO UPDATE SET psk_id = excluded.psk_id, psk = excluded.psk",
        )?;
        let id_sha = crate::sha256(&self.psk_id);
        let id_sha = id_sha.to_sql()?;
        let psk_id = self.psk_id.to_sql()?;
        let psk = self.psk.to_sql()?;

        statement.execute([id_sha, psk_id, psk])?;
        Ok(())
    }

    /// Use the transaction's interface to count the number of entities of this type in the database.
    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        count_helper_tx::<Self>(tx).await
    }

    /// Use the transaction's inteface to delete this entity from the database.
    ///
    /// Returns `true` if at least one entity was deleted, or `false` if the id was not found in the database.
    async fn delete(tx: &Self::Transaction, id: &<Self as Entity>::PrimaryKey) -> CryptoKeystoreResult<bool> {
        <Self as EntityTransactionDeleteBorrowed<'a>>::delete_borrowed(tx, id).await
    }
}

/// Extend an [`Entity`] with db-mutating operations which can be performed when provided with a transaction.
#[async_trait]
impl<'a> EntityTransactionDeleteBorrowed<'a> for StoredPskBundle {
    /// Delete an entity by a borrowed form of its primary key.
    ///
    /// The type signature here is somewhat complicated, but it breaks down simply: if our primary key is something
    /// like `Vec<u8>`, we want to be able to use this method even if what we have on hand is `&[u8]`.
    async fn delete_borrowed<Q>(
        tx: &<Self as EntityTransactionExt<'a>>::Transaction,
        id: &Q,
    ) -> CryptoKeystoreResult<bool>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        let key_hash = crate::sha256(id.bytes().as_ref());
        delete_helper::<Self>(tx, "id_sha256", key_hash).await
    }
}

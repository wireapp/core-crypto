use async_trait::async_trait;
use rusqlite::{OptionalExtension, Row, params};

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult, MissingKeyErrorKind,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::{
        Entity, EntityBase, EntityFindParams, EntityTransactionExt, ProteusIdentity, StringEntityId, count_helper,
        count_helper_tx, load_all_helper,
    },
    traits::{Entity as NewEntity, EntityBase as NewEntityBase, EntityDatabaseMutation, UniqueEntity},
};

#[async_trait::async_trait]
impl Entity for ProteusIdentity {
    fn id_raw(&self) -> &[u8] {
        Self::ID
    }

    async fn find_all(
        conn: &mut Self::ConnectionType,
        _params: EntityFindParams,
    ) -> crate::CryptoKeystoreResult<Vec<Self>> {
        let mut res = vec![];
        if let Some(identity) = Self::find_one(conn, &StringEntityId::default()).await? {
            res.push(identity);
        }

        Ok(res)
    }

    async fn find_one(
        conn: &mut Self::ConnectionType,
        _id: &StringEntityId,
    ) -> crate::CryptoKeystoreResult<Option<Self>> {
        let mut conn = conn.conn().await;
        let transaction = conn.transaction()?;

        let mut row_id: Option<i64> = transaction
            .query_row(
                "SELECT rowid FROM proteus_identities ORDER BY rowid ASC LIMIT 1",
                [],
                |r| r.get(0),
            )
            .optional()?;

        let row_id = if let Some(rowid) = row_id.take() {
            rowid
        } else {
            return Ok(None);
        };

        use std::io::Read as _;
        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "pk", row_id, true)?;
        if blob.len() != Self::PK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::PK_KEY_SIZE,
                actual: blob.len(),
                key: "pk",
            });
        }
        let mut pk = Vec::with_capacity(blob.len());
        blob.read_to_end(&mut pk)?;
        blob.close()?;

        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "sk", row_id, true)?;
        if blob.len() != Self::SK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::SK_KEY_SIZE,
                actual: blob.len(),
                key: "sk",
            });
        }
        let mut sk = Vec::with_capacity(blob.len());
        blob.read_to_end(&mut sk)?;
        blob.close()?;

        Ok(Some(Self { pk, sk }))
    }

    async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<usize> {
        let conn = conn.conn().await;
        let count = conn.query_row("SELECT COUNT(*) FROM proteus_identities", [], |r| r.get(0))?;
        // This should always be less or equal 1
        debug_assert!(count <= 1);
        Ok(count)
    }
}

#[async_trait::async_trait]
impl EntityBase for ProteusIdentity {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "proteus_identities";

    fn to_missing_key_err_kind() -> MissingKeyErrorKind {
        MissingKeyErrorKind::ProteusIdentity
    }

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::ProteusIdentity(self)
    }
}

#[async_trait::async_trait]
impl EntityTransactionExt for ProteusIdentity {
    async fn save(&self, transaction: &TransactionWrapper<'_>) -> crate::CryptoKeystoreResult<()> {
        use rusqlite::ToSql as _;
        transaction.execute(
            "INSERT INTO proteus_identities (sk, pk) VALUES (?, ?)",
            [
                rusqlite::blob::ZeroBlob(self.sk.len() as i32).to_sql()?,
                rusqlite::blob::ZeroBlob(self.pk.len() as i32).to_sql()?,
            ],
        )?;

        let row_id = transaction.last_insert_rowid();

        use std::io::Write as _;
        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "sk", row_id, false)?;
        blob.write_all(&self.sk)?;
        blob.close()?;

        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "pk", row_id, false)?;
        blob.write_all(&self.pk)?;
        blob.close()?;

        Ok(())
    }

    async fn delete_fail_on_missing_id(
        transaction: &TransactionWrapper<'_>,
        _id: StringEntityId<'_>,
    ) -> crate::CryptoKeystoreResult<()> {
        let row_id = transaction.query_row(
            "SELECT rowid FROM proteus_identities ORDER BY rowid ASC LIMIT 1",
            [],
            |r| r.get::<_, i64>(0),
        )?;
        use rusqlite::ToSql as _;
        transaction.execute("DELETE FROM proteus_identities WHERE rowid = ?", [row_id.to_sql()?])?;

        Ok(())
    }
}

impl ProteusIdentity {
    fn from_row(row: &Row<'_>) -> rusqlite::Result<Self> {
        let sk = row.get("sk")?;
        let pk = row.get("pk")?;
        Ok(Self { sk, pk })
    }
}

impl NewEntityBase for ProteusIdentity {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "proteus_identities";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::ProteusIdentity(self)
    }
}

impl UniqueEntity for ProteusIdentity {
    const KEY: () = ();
}

#[async_trait]
impl NewEntity for ProteusIdentity {
    type PrimaryKey = ();
    fn primary_key(&self) -> Self::PrimaryKey {}

    async fn get(conn: &mut Self::ConnectionType, _key: &()) -> CryptoKeystoreResult<Option<Self>> {
        let conn = conn.conn().await;
        let mut stmt = conn.prepare_cached("SELECT rowid FROM proteus_identities ORDER BY rowid ASC LIMIT 1")?;
        stmt.query_one([], Self::from_row).optional().map_err(Into::into)
    }

    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        count_helper::<Self>(conn).await
    }

    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        load_all_helper::<Self, _>(conn, Self::from_row).await
    }
}

#[async_trait]
impl<'a> EntityDatabaseMutation<'a> for ProteusIdentity {
    type Transaction = TransactionWrapper<'a>;

    async fn save(&'a self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        let mut stmt = tx.prepare_cached("INSERT INTO proteus_identities (sk, pk) VALUES (?, ?)")?;
        stmt.execute(params![self.sk, self.pk])?;
        Ok(())
    }

    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        count_helper_tx::<Self>(tx).await
    }

    async fn delete(tx: &Self::Transaction, _id: &()) -> CryptoKeystoreResult<bool> {
        let mut stmt = tx.prepare_cached("DELETE FROM proteus_identities")?;
        let updates = stmt.execute([])?;
        Ok(updates > 0)
    }
}

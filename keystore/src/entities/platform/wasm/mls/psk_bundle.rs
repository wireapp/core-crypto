// #[async_trait::async_trait(?Send)]
// impl EntityTransactionExt for StoredPskBundle {}

use std::borrow::Borrow;

use async_trait::async_trait;

use crate::{
    CryptoKeystoreResult, Entity, EntityBase, EntityEncryptionExt, EntityGetBorrowed, EntityTransactionDeleteBorrowed,
    EntityTransactionExt, KeyType,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::StoredPskBundle,
};

#[async_trait(?Send)]
impl EntityBase for StoredPskBundle {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "mls_psk_bundles";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::PskBundle(self)
    }
}

#[async_trait(?Send)]
impl Entity for StoredPskBundle {
    type PrimaryKey = Vec<u8>;

    fn primary_key(&self) -> Vec<u8> {
        self.psk_id.clone()
    }

    async fn get(conn: &mut Self::ConnectionType, id: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
        Self::get_borrowed(conn, id).await
    }

    async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
        conn.storage().count(Self::COLLECTION_NAME).await.map(Into::into)
    }

    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        conn.storage().get_all(Self::COLLECTION_NAME).await
    }
}

#[async_trait(?Send)]
impl EntityEncryptionExt for StoredPskBundle {
    fn encrypt(&mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        self.psk = self.encrypt_data(cipher, self.psk.as_slice())?;
        Self::ConnectionType::check_buffer_size(self.psk.len())?;

        Ok(())
    }

    fn decrypt(&mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        self.psk = self.decrypt_data(cipher, self.psk.as_slice())?;

        Ok(())
    }
}

#[async_trait(?Send)]
impl EntityGetBorrowed for StoredPskBundle {
    /// Get an entity by a borrowed form of its primary key.
    ///
    /// The type signature here is somewhat complicated, but it breaks down simply: if our primary key is something
    /// like `Vec<u8>`, we want to be able to use this method even if what we have on hand is `&[u8]`.
    async fn get_borrowed<Q>(conn: &mut Self::ConnectionType, key: &Q) -> CryptoKeystoreResult<Option<Self>>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        conn.storage().get(Self::COLLECTION_NAME, key.bytes()).await
    }
}

#[async_trait(?Send)]
impl<'a> EntityTransactionExt<'a> for StoredPskBundle {
    type Transaction = TransactionWrapper<'a>;

    /// Use the transaction's interface to save this entity to the database
    async fn save(&self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        tx.save(self).await
    }

    /// Use the transaction's interface to count the number of entities of this type in the database.
    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        tx.count::<Self>().await
    }

    /// Use the transaction's inteface to delete this entity from the database.
    ///
    /// Returns `true` if at least one entity was deleted, or `false` if the id was not found in the database.
    async fn delete(tx: &Self::Transaction, id: &<Self as Entity>::PrimaryKey) -> CryptoKeystoreResult<bool> {
        <Self as EntityTransactionDeleteBorrowed<'a>>::delete_borrowed(tx, id).await
    }
}

/// Extend an [`Entity`] with db-mutating operations which can be performed when provided with a transaction.
#[async_trait(?Send)]
impl<'a> EntityTransactionDeleteBorrowed<'a> for StoredPskBundle {
    /// Delete an entity by a borrowed form of its primary key.
    ///
    /// The type signature here is somewhat complicated, but it breaks down simply: if our primary key is something
    /// like `Vec<u8>`, we want to be able to use this method even if what we have on hand is `&[u8]`.
    async fn delete_borrowed<Q>(
        tx: &<Self as EntityTransactionExt<'a>>::Transaction,
        id: &Q,
    ) -> CryptoKeystoreResult<bool>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        tx.delete(Self::COLLECTION_NAME, id.bytes().as_ref()).await
    }
}

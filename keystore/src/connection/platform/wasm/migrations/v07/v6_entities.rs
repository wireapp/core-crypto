use async_trait::async_trait;
use web_time::SystemTime;
use zeroize::ZeroizeOnDrop;

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult, Sha256Hash,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    migrations::V6Credential,
    traits::{
        DecryptData as _, Decryptable, Decrypting, EncryptData as _, Encrypting, Entity, EntityBase,
        EntityDatabaseMutation, KeyType as _, PrimaryKey,
    },
};

impl EntityBase for V6Credential {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = u64;
    const COLLECTION_NAME: &'static str = "mls_credentials";
}

impl PrimaryKey for V6Credential {
    type PrimaryKey = Sha256Hash;

    fn primary_key(&self) -> Self::PrimaryKey {
        Sha256Hash::hash_from(&self.public_key)
    }
}

#[async_trait(?Send)]
impl Entity for V6Credential {
    async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CryptoKeystoreResult<Option<Self>> {
        conn.storage().get(key.bytes().as_ref()).await
    }

    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        conn.storage().count::<Self>().await
    }

    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        conn.storage().get_all().await
    }
}

#[async_trait(?Send)]
impl<'a> EntityDatabaseMutation<'a> for V6Credential {
    type Transaction = TransactionWrapper<'a>;

    async fn pre_save(&mut self) -> CryptoKeystoreResult<Self::AutoGeneratedFields> {
        let now = SystemTime::now();
        let created_at = now
            .duration_since(SystemTime::UNIX_EPOCH)
            .map_err(|_| CryptoKeystoreError::TimestampError)?
            .as_secs();
        self.created_at = created_at;
        Ok(created_at)
    }

    async fn save(&'a self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        tx.save(self).await
    }

    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        tx.count::<Self>().await
    }

    async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> CryptoKeystoreResult<bool> {
        tx.delete::<Self>(id.bytes().as_ref()).await
    }
}

/// The encrypted form of a stored credential
#[expect(unreachable_pub)]
#[derive(ZeroizeOnDrop, serde::Deserialize, serde::Serialize)]
pub struct EncryptedV6Credential {
    signature_scheme: u16,
    session_id: Vec<u8>,
    credential: Vec<u8>,
    created_at: u64,
    public_key: Vec<u8>,
    private_key: Vec<u8>,
}

impl<'a> Encrypting<'a> for V6Credential {
    type EncryptedForm = EncryptedV6Credential;

    fn encrypt(&'a self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::EncryptedForm> {
        let credential = V6Credential::encrypt_data(self, cipher, &self.credential)?;
        let private_key = V6Credential::encrypt_data(self, cipher, &self.private_key)?;

        Ok(EncryptedV6Credential {
            signature_scheme: self.signature_scheme,
            created_at: self.created_at,
            session_id: self.session_id.clone(),
            public_key: self.public_key.clone(),
            credential,
            private_key,
        })
    }
}

impl Decrypting<'static> for EncryptedV6Credential {
    type DecryptedForm = V6Credential;

    fn decrypt(mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::DecryptedForm> {
        // we encrypt only two fields here: the serialized form of the credential itself,
        // and the private key
        let primary_key = Sha256Hash::hash_from(&self.public_key);
        let credential = V6Credential::decrypt_data(cipher, &primary_key, &self.credential)?;
        let private_key = V6Credential::decrypt_data(cipher, &primary_key, &self.private_key)?;

        Ok(V6Credential {
            signature_scheme: self.signature_scheme,
            created_at: self.created_at,
            session_id: std::mem::take(&mut self.session_id),
            public_key: std::mem::take(&mut self.public_key),
            credential,
            private_key,
        })
    }
}

impl Decryptable<'static> for V6Credential {
    type DecryptableFrom = EncryptedV6Credential;
}

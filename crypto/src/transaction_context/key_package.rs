//! This module contains all transactional behavior related to key packages

use std::time::Duration;

use openmls::prelude::{KeyPackage, KeyPackageRef};

use super::{Result, TransactionContext};
use crate::{Ciphersuite, CredentialRef, CredentialType, RecursiveError};

impl TransactionContext {
    /// Returns the count of valid, non-expired, unclaimed keypackages in store for the given [Ciphersuite] and [CredentialType]
    pub async fn client_valid_key_packages_count(
        &self,
        ciphersuite: Ciphersuite,
        credential_type: CredentialType,
    ) -> Result<usize> {
        let session = self.session().await?;
        session
            .valid_keypackages_count(&self.mls_provider().await?, ciphersuite, credential_type)
            .await
            .map_err(RecursiveError::mls_client("counting valid key packages"))
            .map_err(Into::into)
    }

    /// Prunes local KeyPackages after making sure they also have been deleted on the backend side
    /// You should only use this after [TransactionContext::save_x509_credential]
    pub async fn delete_keypackages(&self, refs: impl IntoIterator<Item = KeyPackageRef>) -> Result<()> {
        let mut session = self.session().await?;
        session
            .prune_keypackages_and_credential(&self.mls_provider().await?, refs)
            .await
            .map_err(RecursiveError::mls_client("pruning key packages and credential"))
            .map_err(Into::into)
    }

    /// Generate a [KeyPackage] from the referenced credential.
    ///
    /// Makes no attempt to look up or prune existing keypackges.
    ///
    /// If `lifetime` is set, the keypackages will expire that span into the future.
    /// If it is unset, [`KEYPACKAGE_DEFAULT_LIFETIME`][crate::mls::session::key_package::KEYPACKAGE_DEFAULT_LIFETIME]
    /// is used.
    pub async fn generate_keypackage(
        &self,
        credential_ref: &CredentialRef,
        lifetime: Option<Duration>,
    ) -> Result<KeyPackage> {
        let session = self.session().await?;
        session
            .generate_keypackage(credential_ref, lifetime)
            .await
            .map_err(RecursiveError::mls_client("generating keypackage for transaction"))
            .map_err(Into::into)
    }

    /// Get all [`KeyPackageRef`]s known to the keystore.
    pub async fn get_keypackage_refs(&self) -> Result<Vec<KeyPackageRef>> {
        let session = self.session().await?;
        session
            .get_keypackage_refs()
            .await
            .map_err(RecursiveError::mls_client(
                "getting all key package refs for transaction",
            ))
            .map_err(Into::into)
    }

    /// Remove a [`KeyPackage`] from the keystore.
    pub async fn remove_keypackage(&self, kp_ref: &KeyPackageRef) -> Result<()> {
        let session = self.session().await?;
        session
            .remove_keypackage(kp_ref)
            .await
            .map_err(RecursiveError::mls_client("removing a keypackage for transaction"))
            .map_err(Into::into)
    }

    /// Remove all [`KeyPackage`]s associated with this ref.
    pub async fn remove_keypackages_for(&self, credential_ref: &CredentialRef) -> Result<()> {
        let session = self.session().await?;
        session
            .remove_keypackages_for(credential_ref)
            .await
            .map_err(RecursiveError::mls_client(
                "removing all keypackages for credential ref for transaction",
            ))
            .map_err(Into::into)
    }
}

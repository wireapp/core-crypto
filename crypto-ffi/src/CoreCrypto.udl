[Custom]
typedef sequence<u8> ConversationId;

[Custom]
typedef sequence<u8> MemberId;

[Custom]
typedef sequence<u8> ClientId;

dictionary MemberAddedMessages {
    sequence<u8> commit;
    sequence<u8> welcome;
    sequence<u8> public_group_state;
};

[Custom]
typedef sequence<u8> TlsCommitBundle;

dictionary CommitBundle {
    sequence<u8>? welcome;
    sequence<u8> commit;
    sequence<u8> public_group_state;
};

enum CiphersuiteName {
    "MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519",
    "MLS_128_DHKEMP256_AES128GCM_SHA256_P256",
    "MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519",
    "MLS_256_DHKEMX448_AES256GCM_SHA512_Ed448",
    "MLS_256_DHKEMP521_AES256GCM_SHA512_P521",
    "MLS_256_DHKEMX448_CHACHA20POLY1305_SHA512_Ed448",
    "MLS_256_DHKEMP384_AES256GCM_SHA384_P384"
};

[Error]
enum CryptoError {
    "ConversationNotFound",
    "ClientNotFound",
    "PendingProposalNotFound",
    "PendingCommitNotFound",
    "MalformedIdentifier",
    "ClientSignatureNotFound",
    "ClientSignatureMismatch",
    "LockPoisonError",
    "ImplementationError",
    "OutOfKeyPackage",
    "MlsProviderError",
    "KeyStoreError",
    "MlsError",
    "Base64DecodingError",
    "Utf8Error",
    "StringUtf8Error",
    "ParseIntError",
    "ConvertIntError",
    "InvalidByteArrayError",
    "IoError",
    "Unauthorized",
    "CallbacksNotSet",
    "ExternalAddProposalError",
    "InvalidHashReference",
    "GenerationOutOfBound",
};

dictionary DecryptedMessage {
    sequence<u8>? message;
    sequence<ProposalBundle> proposals;
    boolean is_active;
    u64? commit_delay;
    ClientId? sender_client_id;
};

dictionary Invitee {
    ClientId id;
    sequence<u8> kp;
};

dictionary ProposalBundle {
    sequence<u8> proposal;
    sequence<u8> proposal_ref;
};

dictionary MlsConversationInitMessage {
    sequence<u8> group;
    sequence<u8> commit;
};

dictionary ConversationConfiguration {
    sequence<MemberId> admins;
    CiphersuiteName? ciphersuite;
    duration? key_rotation_span;
    sequence<sequence<u8>> external_senders;
};

callback interface CoreCryptoCallbacks {
    boolean authorize([ByRef] sequence<u8> conversation_id, [ByRef] sequence<u8> client_id);
    boolean client_id_belongs_to_one_of([ByRef] sequence<u8> client_id, [ByRef] sequence<sequence<u8>> other_clients);
};

interface CoreCrypto {
    [Throws=CryptoError, Name=new]
    constructor([ByRef] string path, [ByRef] string key, [ByRef] string client_id, sequence<u8>? entropy_seed);

    [Throws=CryptoError]
    void set_callbacks(CoreCryptoCallbacks callbacks);

    [Throws=CryptoError]
    sequence<u8> client_public_key();

    [Throws=CryptoError]
    sequence<sequence<u8>> client_keypackages(u32 amount_requested);

    [Throws=CryptoError]
    u64 client_valid_keypackages_count();

    [Throws=CryptoError]
    void create_conversation(ConversationId conversation_id, ConversationConfiguration config);

    [Throws=CryptoError]
    u64 conversation_epoch(ConversationId conversation_id);

    boolean conversation_exists(ConversationId conversation_id);

    [Throws=CryptoError]
    ConversationId process_welcome_message([ByRef] sequence<u8> welcome_message);

    [Throws=CryptoError]
    MemberAddedMessages add_clients_to_conversation(ConversationId conversation_id, sequence<Invitee> clients);

    [Throws=CryptoError]
    CommitBundle remove_clients_from_conversation(ConversationId conversation_id, sequence<ClientId> clients);

    [Throws=CryptoError]
    CommitBundle update_keying_material(ConversationId conversation_id);

    [Throws=CryptoError]
    CommitBundle? commit_pending_proposals(ConversationId conversation_id);

    [Throws=CryptoError]
    TlsCommitBundle final_add_clients_to_conversation(ConversationId conversation_id, sequence<Invitee> clients);

    [Throws=CryptoError]
    TlsCommitBundle final_remove_clients_from_conversation(ConversationId conversation_id, sequence<ClientId> clients);

    [Throws=CryptoError]
    TlsCommitBundle final_update_keying_material(ConversationId conversation_id);

    [Throws=CryptoError]
    TlsCommitBundle? final_commit_pending_proposals(ConversationId conversation_id);

    [Throws=CryptoError]
    void wipe_conversation(ConversationId conversation_id);

    [Throws=CryptoError]
    DecryptedMessage decrypt_message(ConversationId conversation_id, [ByRef] sequence<u8> payload);

    [Throws=CryptoError]
    sequence<u8> encrypt_message(ConversationId conversation_id, [ByRef] sequence<u8> message);

    [Throws=CryptoError]
    ProposalBundle new_add_proposal(ConversationId conversation_id, sequence<u8> key_package);

    [Throws=CryptoError]
    ProposalBundle new_update_proposal(ConversationId conversation_id);

    [Throws=CryptoError]
    ProposalBundle new_remove_proposal(ConversationId conversation_id, ClientId client_id);

    [Throws=CryptoError]
    sequence<u8> new_external_add_proposal(ConversationId conversation_id, u64 epoch);

    [Throws=CryptoError]
    sequence<u8> new_external_remove_proposal(ConversationId conversation_id, u64 epoch, sequence<u8> key_package_ref);

    [Throws=CryptoError]
    MlsConversationInitMessage join_by_external_commit(sequence<u8> group_state);

    [Throws=CryptoError]
    sequence<u8> export_group_state(ConversationId conversation_id);

    [Throws=CryptoError]
    void merge_pending_group_from_external_commit(ConversationId conversation_id, ConversationConfiguration config);

    [Throws=CryptoError]
    sequence<u8> random_bytes(u32 length);

    [Throws=CryptoError]
    void reseed_rng(sequence<u8> seed);

    [Throws=CryptoError]
    void commit_accepted(ConversationId conversation_id);

    [Throws=CryptoError]
    void clear_pending_proposal(ConversationId conversation_id, sequence<u8> proposal_ref);

    [Throws=CryptoError]
    void clear_pending_commit(ConversationId conversation_id);
};

namespace CoreCrypto {
    [Throws=CryptoError]
    CoreCrypto init_with_path_and_key([ByRef] string path, [ByRef] string key, [ByRef] string client_id, sequence<u8>? entropy_seed);

    string version();
};

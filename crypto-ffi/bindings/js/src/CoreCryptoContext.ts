import {
    Ciphersuite,
    ClientId,
    CoreCryptoContext as CoreCryptoContextFfi,
    type ClientIdInterface,
    type CredentialRefInterface,
} from "./autogenerated/core_crypto_ffi";
import * as CoreCryptoFfiTypes from "./autogenerated/core_crypto_ffi";

import { mlsTransportToFfi, type MlsTransport } from "./CoreCryptoMLS";

export interface CredentialFindFilters {
    clientId?: ClientId;
    publicKey?: ArrayBuffer;
    ciphersuite?: Ciphersuite;
    credentialType?: CredentialType;
    earliestValidity?: bigint;
}

export class CoreCryptoContext extends CoreCryptoContextFfi {
    /** @internal */
    constructor(ctx: CoreCryptoContextFfi) {
        super(ctx);
    }

    /** @internal */
    static instanceOf(obj: unknown): obj is CoreCryptoContextFfi {
        return super.instanceOf(obj);
    }

    /**
     * Use this after {@link CoreCrypto.init} when you have a clientId. It initializes MLS.
     * Registers the transport callbacks for core crypto to give it access to backend endpoints for sending
     * a commit bundle or a message, respectively.
     *
     * @param clientId - required
     * @param transport - Any implementor of the {@link MlsTransport} interface
     */
    async mlsInitialize(
        clientId: ClientId,
        transport: MlsTransport
    ): Promise<void> {
        return await super.mlsInit(clientId, mlsTransportToFfi(transport));
    }

    /** @internal */
    async mlsInit(
        clientId: ClientIdInterface,
        transport: CoreCryptoFfiTypes.MlsTransport,
        asyncOpts_?: { signal: AbortSignal }
    ): Promise<void> {
        super.mlsInit(clientId, transport, asyncOpts_);
    }

    /**
     * Creates an enrollment instance with private key material you can use in order to fetch
     * a new x509 certificate from the acme server.
     *
     * @param clientId - client identifier e.g. `b7ac11a4-8f01-4527-af88-1c30885a7931:6add501bacd1d90e@example.com`
     * @param displayName - human-readable name displayed in the application e.g. `Smith, Alice M (QA)`
     * @param handle - user handle e.g. `alice.smith.qa@example.com`
     * @param expirySec - generated x509 certificate expiry
     * @param ciphersuite - for generating signing key material
     * @param team - name of the Wire team a user belongs to
     * @returns The new {@link E2eiEnrollment} enrollment instance to use with {@link CoreCryptoContext.e2eiMlsInitOnly}
     */
    async e2eiNewEnrollment(
        clientId: string,
        displayName: string,
        handle: string,
        expirySec: number,
        ciphersuite: Ciphersuite,
        team?: string
    ): Promise<E2eiEnrollment> {
        const e2ei = await CoreCryptoError.asyncMapErr(
            this.#ctx.e2eiNewEnrollment(
                clientId,
                displayName,
                handle,
                team,
                expirySec,
                ciphersuite
            )
        );
        return new E2eiEnrollment(e2ei);
    }

    /**
     * Use this method to initialize end-to-end identity when a client signs up and the grace period is already expired ;
     * that means he cannot initialize with a Basic credential
     *
     * @param enrollment - the enrollment instance used to fetch the certificates
     * @param certificateChain - the raw response from ACME server
     * @returns a MlsClient initialized with only a x509 credential
     */
    async e2eiMlsInitializeOnly(
        enrollment: E2eiEnrollmentInterface,
        certificateChain: string,
        transport: MlsTransport
    ): Promise<CredentialRefInterface> {
        return await super.e2eiMlsInitOnly(
            enrollment,
            certificateChain,
            mlsTransportToFfi(transport)
        );
    }

    /** @internal */
    async e2eiMlsInitOnly(
        enrollment: E2eiEnrollmentInterface,
        certificateChain: string,
        transport: CoreCryptoFfiTypes.MlsTransport
    ): Promise<CredentialRefInterface> {
        return await super.e2eiMlsInitOnly(
            enrollment,
            certificateChain,
            transport
        );
    }

    /**
     * Get those credentials known to this instance which match the provided filters
     *
     * @param findFilters a set of filters defining which credentials are of interest.
     */
    async findCredentials(
        findFilters: CredentialFindFilters
    ): Promise<CredentialRefInterface[]> {
        return await CoreCryptoError.asyncMapErr(
            this.#ctx.findCredentials(
                findFilters.clientId,
                findFilters.publicKey,
                findFilters.ciphersuite,
                findFilters.credentialType,
                findFilters.earliestValidity
            )
        );
    }

}

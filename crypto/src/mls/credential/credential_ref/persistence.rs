//! Persistence for [`CredentialRef`], i.e. loading actual credentials from the keystore given a ref.
//!
//! It is not logically required that these methods are crate-private, but they aren't likely to be
//! useful to end users. Clients building on the CC API can't do anything useful with a full [`Credential`],
//! and it's wasteful to transfer one across the FFI boundary.

use core_crypto_keystore::{
    connection::FetchFromDatabase as _,
    entities::{EntityFindParams, StoredCredential, StoredSignatureKeypair},
};
use mls_crypto_provider::Database;
use openmls::prelude::Credential as MlsCredential;
use tls_codec::Deserialize as _;

use super::{super::keypairs, Error, Result};
use crate::{Credential, CredentialRef, KeystoreError, RecursiveError};

/// Helper struct caching relevant data from the keystore.
///
/// This is generated by [`CredentialRef::load_cache`]. It's only relevant when you want to
/// load multiple credentials at once. For single loads, prefer [`CredentialRef::load`].
//
// We'd very much like it if in the future we could do filtering at the database level,
// obviating the requirement for this cache structure. See WPB-20839 and WPB-20844.
pub(crate) struct Cache {
    keypairs: Vec<StoredSignatureKeypair>,
    credentials: Vec<StoredCredential>,
}

impl CredentialRef {
    /// Helper to prefetch relevant keypairs when loading multiple credentials at a time.
    ///
    /// Only useful when preparing to call [`Self::load_with_cache`] multiple times.
    /// For loading a single credential, prefer [`Self::load`].
    pub(crate) async fn load_cache(database: &Database) -> Result<Cache> {
        let keypairs = keypairs::load_all(database)
            .await
            .map_err(RecursiveError::mls_credential("loading all keypairs for cache"))?;
        let credentials = database
            .find_all::<StoredCredential>(EntityFindParams::default())
            .await
            .map_err(KeystoreError::wrap("finding all mls credentials"))?;
        Ok(Cache { keypairs, credentials })
    }

    /// Load all credentials which match this ref from the database.
    ///
    /// Note that this does not attach the credential to any Session; it just does the data manipulation.
    ///
    /// The database schema currently permits multiple credentials to exist simultaneously which match a given credential ref.
    /// Therefore, this function returns all of them, ordered by `earliest_validity`.
    ///
    /// Due to database limitations we currently cannot efficiently retrieve only those keypairs of interest;
    /// if you are going to be loading several references in a row, it is more efficient to first fetch all
    /// stored keypairs with [`Self::load_cache`] and then call [`Self::load_with_cache`].
    pub(crate) async fn load(&self, database: &Database) -> Result<Vec<Credential>> {
        let cache = Self::load_cache(database).await?;
        let credentials = self.load_with_cache(&cache).await?.collect::<Result<Vec<_>>>()?;
        Ok(credentials)
    }

    /// Load this credential from the database.
    ///
    /// Note that this does not attach the credential to any Session; it just does the data manipulation.
    ///
    /// The database schema currently permits multiple credentials to exist simultaneously which match a given credential ref.
    /// Therefore, this function returns a possibly-empty iterator over all of them, ordered by `earliest_validity`.
    ///
    /// If you are only loading a single credential ref, it may be simpler to call [`Self::load`].
    pub(crate) async fn load_with_cache<'cache, 'cref>(
        &'cref self,
        Cache { keypairs, credentials }: &'cache Cache,
    ) -> Result<impl 'cache + Iterator<Item = Result<Credential>>>
    where
        'cref: 'cache,
    {
        let signature_key_pair =
            keypairs::find_matching(keypairs, self.client_id(), self.signature_scheme(), self.public_key())
                .await
                .map_err(RecursiveError::mls_credential(
                    "finding matching key pairs while loading credential",
                ))?
                .ok_or(Error::KeypairNotFound)?;

        let iter = credentials
            .iter()
            // this is the only check we can currently do at the DB level: match the client id and creation timestamp
            .filter(|stored_credential| stored_credential.id == self.client_id().as_slice() && stored_credential.created_at == self.earliest_validity)
            // from here we can at least deserialize the credential
            .map(move |stored_credential| {
                let mls_credential = MlsCredential::tls_deserialize(&mut stored_credential.credential.as_slice())
                    .map_err(Error::tls_deserialize("mls credential"))?;
                let earliest_validity = stored_credential.created_at;
                Ok(Credential {
                    signature_key_pair: signature_key_pair.clone(),
                    mls_credential,
                    earliest_validity,
                })
            })
            // after deserialization, we can filter out any results which do not match the conditions in the credential ref
            // but pass through any errors
            .filter(|credential_result| {
                credential_result
                    .as_ref()
                    .map(|credential| {
                        credential.signature_key_pair.signature_scheme() == self.signature_scheme()
                            && credential.mls_credential.credential_type() == self.r#type()
                    })
                    .unwrap_or(true)
            })
            // we also need to ensure that the credential validates
            .map(|credential_result| {
                credential_result.and_then(|credential| {
                    Credential::validate_mls_credential(
                        &credential.mls_credential,
                        self.client_id(),
                        &credential.signature_key_pair,
                    )?;
                    Ok(credential)
                })
            });

        Ok(iter)
    }
}

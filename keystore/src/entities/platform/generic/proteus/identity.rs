use rusqlite::OptionalExtension;

use crate::{
    CryptoKeystoreError, MissingKeyErrorKind,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::{Entity, EntityBase, EntityFindParams, EntityTransactionExt, ProteusIdentity, StringEntityId},
};

#[async_trait::async_trait]
impl Entity for ProteusIdentity {
    fn id_raw(&self) -> &[u8] {
        Self::ID
    }

    async fn find_all(
        conn: &mut Self::ConnectionType,
        _params: EntityFindParams,
    ) -> crate::CryptoKeystoreResult<Vec<Self>> {
        let mut res = vec![];
        if let Some(identity) = Self::find_one(conn, &StringEntityId::default()).await? {
            res.push(identity);
        }

        Ok(res)
    }

    async fn find_one(
        conn: &mut Self::ConnectionType,
        _id: &StringEntityId,
    ) -> crate::CryptoKeystoreResult<Option<Self>> {
        let mut conn = conn.conn().await;
        let transaction = conn.transaction()?;

        let mut row_id: Option<i64> = transaction
            .query_row(
                "SELECT rowid FROM proteus_identities ORDER BY rowid ASC LIMIT 1",
                [],
                |r| r.get(0),
            )
            .optional()?;

        let row_id = if let Some(rowid) = row_id.take() {
            rowid
        } else {
            return Ok(None);
        };

        use std::io::Read as _;
        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "pk", row_id, true)?;
        if blob.len() != Self::PK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::PK_KEY_SIZE,
                actual: blob.len(),
                key: "pk",
            });
        }
        let mut pk = Vec::with_capacity(blob.len());
        blob.read_to_end(&mut pk)?;
        blob.close()?;

        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "sk", row_id, true)?;
        if blob.len() != Self::SK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::SK_KEY_SIZE,
                actual: blob.len(),
                key: "sk",
            });
        }
        let mut sk = Vec::with_capacity(blob.len());
        blob.read_to_end(&mut sk)?;
        blob.close()?;

        Ok(Some(Self { pk, sk }))
    }

    async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<usize> {
        let conn = conn.conn().await;
        let count = conn.query_row("SELECT COUNT(*) FROM proteus_identities", [], |r| r.get(0))?;
        // This should always be less or equal 1
        debug_assert!(count <= 1);
        Ok(count)
    }
}

#[async_trait::async_trait]
impl EntityBase for ProteusIdentity {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "proteus_identities";

    fn to_missing_key_err_kind() -> MissingKeyErrorKind {
        MissingKeyErrorKind::ProteusIdentity
    }

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::ProteusIdentity(self)
    }
}

#[async_trait::async_trait]
impl EntityTransactionExt for ProteusIdentity {
    async fn save(&self, transaction: &TransactionWrapper<'_>) -> crate::CryptoKeystoreResult<()> {
        use rusqlite::ToSql as _;
        transaction.execute(
            "INSERT INTO proteus_identities (sk, pk) VALUES (?, ?)",
            [
                rusqlite::blob::ZeroBlob(self.sk.len() as i32).to_sql()?,
                rusqlite::blob::ZeroBlob(self.pk.len() as i32).to_sql()?,
            ],
        )?;

        let row_id = transaction.last_insert_rowid();

        use std::io::Write as _;
        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "sk", row_id, false)?;
        blob.write_all(&self.sk)?;
        blob.close()?;

        let mut blob = transaction.blob_open(rusqlite::MAIN_DB, "proteus_identities", "pk", row_id, false)?;
        blob.write_all(&self.pk)?;
        blob.close()?;

        Ok(())
    }

    async fn delete_fail_on_missing_id(
        transaction: &TransactionWrapper<'_>,
        _id: StringEntityId<'_>,
    ) -> crate::CryptoKeystoreResult<()> {
        let row_id = transaction.query_row(
            "SELECT rowid FROM proteus_identities ORDER BY rowid ASC LIMIT 1",
            [],
            |r| r.get::<_, i64>(0),
        )?;
        use rusqlite::ToSql as _;
        transaction.execute("DELETE FROM proteus_identities WHERE rowid = ?", [row_id.to_sql()?])?;

        Ok(())
    }
}

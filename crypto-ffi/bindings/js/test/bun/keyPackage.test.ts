import { ccInit, setup, teardown } from "./utils";
import { afterEach, test, beforeEach, describe, expect } from "bun:test";
import { ciphersuiteDefault, ClientId } from "../../src/CoreCrypto";
import {
    Ciphersuite,
    credentialBasic,
    Keypackage,
} from "../../src/autogenerated/core_crypto_ffi";

beforeEach(async () => {
    await setup();
});

afterEach(async () => {
    await teardown();
});

describe("key package", () => {
    test("can be created", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const credentialRef = await cc.transaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        const keyPackage = await cc.transaction(async (ctx) => {
            return await ctx.generateKeypackage(credentialRef);
        });

        expect(keyPackage).toBeDefined();
    });

    test("can be serialized", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const credentialRef = await cc.transaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        const keyPackage = await cc.transaction(async (ctx) => {
            return await ctx.generateKeypackage(credentialRef);
        });

        const bytes = new Uint8Array(keyPackage.serialize());

        expect(bytes).toBeDefined();
        expect(bytes).not.toBeEmpty();

        // roundtrip
        const kp2 = new Keypackage(bytes.buffer);
        const bytes2 = new Uint8Array(kp2.serialize());

        expect(bytes2).toEqual(bytes);
    });

    test("can be retrieved in bulk", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const credentialRef = await cc.transaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        await cc.transaction(async (ctx) => {
            await ctx.generateKeypackage(credentialRef);
        });

        const keyPackages = await cc.transaction(async (ctx) => {
            return await ctx.getKeypackages();
        });

        expect(keyPackages).toBeDefined();
        expect(keyPackages).toBeArrayOfSize(1);
        expect(keyPackages[0]).toBeDefined();
    });

    test("can be removed", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const credentialRef = await cc.transaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        // add a kp which will not be removed, so we have one left over
        await cc.transaction(async (ctx) => {
            await ctx.generateKeypackage(credentialRef);
        });

        // add a kp which will be removed
        const keyPackage = await cc.transaction(async (ctx) => {
            return await ctx.generateKeypackage(credentialRef);
        });

        // now remove the keypackage
        await cc.transaction(async (ctx) => {
            await ctx.removeKeypackage(keyPackage.ref());
        });

        const keyPackages = await cc.transaction(async (ctx) => {
            return await ctx.getKeypackages();
        });

        expect(keyPackages).toBeDefined();
        expect(keyPackages).toBeArrayOfSize(1);
    });

    test("can be removed by credentialref", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential1 = credentialBasic(
            Ciphersuite.Mls128Dhkemx25519Aes128gcmSha256Ed25519,
            clientId
        );
        const credential2 = credentialBasic(
            Ciphersuite.Mls128Dhkemp256Aes128gcmSha256P256,
            clientId
        );
        const cc = await ccInit(clientId);

        await cc.transaction(async (ctx) => {
            const cref1 = await ctx.addCredential(credential1);
            const cref2 = await ctx.addCredential(credential2);

            // we're going to generate keypackages for both credentials,
            // then remove those packages for credential 2, leaving behind those for credential 1
            const KEYPACKAGES_PER_CREDENTIAL = 2;
            for (const cref of [cref1, cref2]) {
                for (let i = 0; i < KEYPACKAGES_PER_CREDENTIAL; i++) {
                    await ctx.generateKeypackage(cref);
                }
            }

            const kpsBeforeRemoval = await ctx.getKeypackages();
            // 2 credentials with the same n keypackages each
            expect(kpsBeforeRemoval).toBeArrayOfSize(
                KEYPACKAGES_PER_CREDENTIAL * 2
            );

            // now remove all keypackages for one of the credentials
            await ctx.removeKeypackagesFor(cref1);

            const kps = await ctx.getKeypackages();
            expect(kps).toBeArrayOfSize(KEYPACKAGES_PER_CREDENTIAL);
        });
    });
});

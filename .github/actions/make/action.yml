name: Fetch or make an artifact
description: Fetch the newest artifact (on the current branch or on main) with a given key.
  If it doesn't exist, run the given command and upload it.
inputs:
  key:
    description: The artifact key
    required: true
  make-rule:
    description: The GNU make rule which produces the artifact
    required: true
  target-path:
    description: The relative path of the final artifact(s)
    required: true
  gh-token:
    required: true

runs:
  using: composite
  steps:
    - name: Set MAKE
      uses: ./.github/actions/make/set-make-executable

    - name: compute artifact key
      shell: bash -euo pipefail {0}
      id: compute-key
      run: |
        files_hash=$($MAKE "${{ inputs.make-rule }}"-hash-deps)
        echo "key=${{ inputs.key }}-$files_hash" >> "$GITHUB_OUTPUT"

    - name: branch name
      id: branch-name
      run: |
        if [[ -n "${GITHUB_HEAD_REF}" ]]; then
          # Pull request
          branch="${GITHUB_HEAD_REF}"
        elif [[ "${GITHUB_REF_TYPE}" == "branch" ]]; then
          # Direct branch push
          branch="${GITHUB_REF_NAME}"
        else
          # Tag push -> resolve the branch the tag points to
          git fetch -f --all --no-tags >/dev/null 2>&1
          branch="$(git branch -r --contains "${GITHUB_SHA}" --format '%(refname:lstrip=3)' | grep -v '^HEAD$' | head -n1)"
        fi
        echo "branch=$branch" >> "$GITHUB_OUTPUT"
      shell: bash -euo pipefail {0}

    - name: Download artifact
      run: |
        branch="${{ steps.branch-name.outputs.branch }}"

        workflow_name="pipeline.yml"
        runs_current_branch=$(gh run list --branch "$branch" --limit 10 -w "$workflow_name" --json databaseId | jq '.[].databaseId')
        runs_main=$(gh run list --branch main --limit 10 -w "$workflow_name" --json databaseId | jq '.[].databaseId')

        # Prepend the current run id, then prioritize current branch over main
        runs=$(printf "%s\n%s\n%s\n" "${{ github.run_id }}" "$runs_current_branch" "$runs_main" | awk 'NF')

        artifact_name="${{ steps.compute-key.outputs.key }}"

        echo "found=false" >> $GITHUB_ENV
        echo "found_in_this_run=false" >> $GITHUB_ENV

        # For each run in the sorted list of run ids, try downloading the artifact
        # with the given name.
        for run_id in $runs; do
          if gh run download "$run_id" -n "$artifact_name" >/dev/null 2>&1; then
            echo "Downloaded artifact $artifact_name from run with id: $run_id"
            echo "found=true" >> $GITHUB_ENV
            if [ "$run_id" = "${{ github.run_id }}" ]; then
              echo "found_in_this_run=true" >> $GITHUB_ENV
            fi
            exit 0
          fi
        done

        echo "No artifact '$artifact_name' found." >&2
      env:
        GITHUB_TOKEN: ${{ inputs.gh-token }}
      shell: bash -euo pipefail {0}

    - name: Unpack and touch downloaded files to update timestamps
      if: env.found == 'true'
      run: |
        tar -xzf artifact.tar.gz
        # This is necessary because the github checkout action doesn't preserve
        # timestamps on checked out files.
        paths="${{ inputs.target-path }}"
        for dir in $paths; do
          if [ -d "$dir" ]; then
            find "$dir" -type f -exec touch {} +
          elif [ -f "$dir" ]; then
            touch "$dir"
          fi
        done
      shell: bash -euo pipefail {0}

    - name: Run make ${{ inputs.make-rule }} if needed
      if: env.found != 'true'
      run: $MAKE ${{ inputs.make-rule }}
      shell: bash -euo pipefail {0}

    - name: Prepare artifact
      run: |
        mkdir -p .stamps
        printf '%s\n' "${{ inputs.target-path }}" | tar -czf artifact.tar.gz -T - .stamps
      shell: bash -euo pipefail {0}

    - name: Upload artifact if it doesn't exist for this workflow run
      if: env.found_in_this_run != 'true'
      uses: actions/upload-artifact@v5.0.0
      with:
        name: ${{ steps.compute-key.outputs.key }}
        path: artifact.tar.gz

    - name: Cleanup
      run: |
        rm artifact.tar.gz
      shell: bash -euo pipefail {0}

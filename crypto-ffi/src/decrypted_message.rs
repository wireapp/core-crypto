// We can't otherwise silence the deprecation warnings generated by macros on the message definitions
#![allow(deprecated)]

use core_crypto::prelude::{MlsBufferedConversationDecryptMessage, MlsConversationDecryptMessage};
#[cfg(target_family = "wasm")]
use wasm_bindgen::prelude::*;

use crate::{ClientId, CoreCryptoError, CoreCryptoResult, NewCrlDistributionPoints, ProposalBundle, WireIdentity};

/// See [core_crypto::prelude::decrypt::MlsConversationDecryptMessage]
#[derive(Debug)]
#[cfg_attr(
    target_family = "wasm",
    wasm_bindgen(getter_with_clone),
    derive(serde::Serialize, serde::Deserialize)
)]
#[cfg_attr(not(target_family = "wasm"), derive(uniffi::Record))]
pub struct DecryptedMessage {
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub message: Option<Vec<u8>>,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub proposals: Vec<ProposalBundle>,
    /// It is set to false if ingesting this MLS message has resulted in the client being removed from the group (i.e. a Remove commit)
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = isActive))]
    pub is_active: bool,
    /// Commit delay hint (in milliseconds) to prevent clients from hammering the server with epoch changes
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = commitDelay))]
    pub commit_delay: Option<u64>,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = senderClientId))]
    pub sender_client_id: Option<ClientId>,
    /// true when the decrypted message resulted in an epoch change i.e. it was a commit
    ///
    /// Deprecated: this member will be removed in the future. Prefer using the `EpochObserver` interface.
    #[deprecated = "This member will be removed in the future. Prefer using the `EpochObserver` interface."]
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = hasEpochChanged))]
    pub has_epoch_changed: bool,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub identity: WireIdentity,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = bufferedMessages))]
    pub buffered_messages: Option<Vec<BufferedDecryptedMessage>>,
    /// New CRL Distribution of members of this group
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = crlNewDistributionPoints))]
    pub crl_new_distribution_points: NewCrlDistributionPoints,
}

impl TryFrom<MlsConversationDecryptMessage> for DecryptedMessage {
    type Error = CoreCryptoError;

    fn try_from(from: MlsConversationDecryptMessage) -> Result<Self, Self::Error> {
        let proposals = from
            .proposals
            .into_iter()
            .map(ProposalBundle::try_from)
            .collect::<CoreCryptoResult<Vec<_>>>()?;

        let buffered_messages = from
            .buffered_messages
            .map(|bm| {
                bm.into_iter()
                    .map(TryInto::try_into)
                    .collect::<CoreCryptoResult<Vec<_>>>()
            })
            .transpose()?;

        #[expect(deprecated)]
        Ok(Self {
            message: from.app_msg,
            proposals,
            is_active: from.is_active,
            commit_delay: from.delay,
            sender_client_id: from.sender_client_id.map(ClientId),
            has_epoch_changed: from.has_epoch_changed,
            identity: from.identity.into(),
            buffered_messages,
            crl_new_distribution_points: from.crl_new_distribution_points.into(),
        })
    }
}

/// to avoid recursive structs
#[derive(Debug, Clone)]
#[cfg_attr(
    target_family = "wasm",
    wasm_bindgen(getter_with_clone),
    derive(serde::Serialize, serde::Deserialize)
)]
#[cfg_attr(not(target_family = "wasm"), derive(uniffi::Record))]
pub struct BufferedDecryptedMessage {
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub message: Option<Vec<u8>>,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub proposals: Vec<ProposalBundle>,
    /// It is set to false if ingesting this MLS message has resulted in the client being removed from the group (i.e. a Remove commit)
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = isActive))]
    pub is_active: bool,
    /// Commit delay hint (in milliseconds) to prevent clients from hammering the server with epoch changes
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = commitDelay))]
    pub commit_delay: Option<u64>,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = senderClientId))]
    pub sender_client_id: Option<ClientId>,
    /// true when the decrypted message resulted in an epoch change i.e. it was a commit
    ///
    /// Deprecated: this member will be removed in the future. Prefer using the `EpochObserver` interface.
    #[deprecated = "This member will be removed in the future. Prefer using the `EpochObserver` interface."]
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = hasEpochChanged))]
    pub has_epoch_changed: bool,
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly))]
    pub identity: WireIdentity,
    /// New CRL Distribution of members of this group
    #[cfg_attr(target_family = "wasm", wasm_bindgen(readonly, js_name = crlNewDistributionPoints))]
    pub crl_new_distribution_points: NewCrlDistributionPoints,
}

impl TryFrom<MlsBufferedConversationDecryptMessage> for BufferedDecryptedMessage {
    type Error = CoreCryptoError;

    fn try_from(from: MlsBufferedConversationDecryptMessage) -> Result<Self, Self::Error> {
        let proposals = from
            .proposals
            .into_iter()
            .map(ProposalBundle::try_from)
            .collect::<CoreCryptoResult<Vec<_>>>()?;

        #[expect(deprecated)]
        Ok(Self {
            message: from.app_msg,
            proposals,
            is_active: from.is_active,
            commit_delay: from.delay,
            sender_client_id: from.sender_client_id.map(ClientId),
            has_epoch_changed: from.has_epoch_changed,
            identity: from.identity.into(),
            crl_new_distribution_points: from.crl_new_distribution_points.into(),
        })
    }
}

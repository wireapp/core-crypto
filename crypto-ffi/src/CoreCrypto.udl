[Custom]
typedef sequence<u8> ClientId;

[Custom]
typedef u16 Ciphersuite;

[Custom]
typedef sequence<u16> Ciphersuites;

dictionary MemberAddedMessages {
    bytes commit;
    bytes welcome;
    GroupInfoBundle group_info;
};

dictionary CommitBundle {
    bytes? welcome;
    bytes commit;
    GroupInfoBundle group_info;
};

dictionary ProteusAutoPrekeyBundle {
    u16 id;
    bytes pkb;
};

dictionary GroupInfoBundle {
    MlsGroupInfoEncryptionType encryption_type;
    MlsRatchetTreeType ratchet_tree_type;
    bytes payload;
};

dictionary DecryptedMessage {
    bytes? message;
    sequence<ProposalBundle> proposals;
    boolean is_active;
    u64? commit_delay;
    ClientId? sender_client_id;
    boolean has_epoch_changed;
    WireIdentity? identity;
};

dictionary WireIdentity {
    string client_id;
    string handle;
    string display_name;
    string domain;
};

dictionary Invitee {
    ClientId id;
    bytes kp;
};

dictionary ProposalBundle {
    bytes proposal;
    bytes proposal_ref;
};

dictionary ConversationInitBundle {
    bytes conversation_id;
    bytes commit;
    GroupInfoBundle group_info;
};

dictionary ConversationConfiguration {
    Ciphersuite ciphersuite;
    sequence<bytes> external_senders;
    CustomConfiguration custom;
    sequence<PerDomainTrustAnchor> per_domain_trust_anchors;
};

dictionary PerDomainTrustAnchor {
    string domain_name;
    string intermediate_certificate_chain;
};

dictionary CustomConfiguration {
    duration? key_rotation_span;
    MlsWirePolicy? wire_policy;
};

dictionary AcmeDirectory {
    string new_nonce;
    string new_account;
    string new_order;
};

dictionary NewAcmeOrder {
    bytes delegate;
    sequence<string> authorizations;
};

dictionary NewAcmeAuthz {
    string identifier;
    AcmeChallenge? wire_dpop_challenge;
    AcmeChallenge? wire_oidc_challenge;
};

dictionary AcmeChallenge {
    bytes delegate;
    string url;
    string target;
};

dictionary RotateBundle {
    record<string, CommitBundle> commits;
    sequence<bytes> new_key_packages;
    sequence<bytes> key_package_refs_to_remove;
};

enum MlsGroupInfoEncryptionType {
    "Plaintext",
    "JweEncrypted",
};

enum MlsRatchetTreeType {
    "Full",
    "Delta",
    "ByRef",
};

enum CiphersuiteName {
    "MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519",
    "MLS_128_DHKEMP256_AES128GCM_SHA256_P256",
    "MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519",
    "MLS_256_DHKEMX448_AES256GCM_SHA512_Ed448",
    "MLS_256_DHKEMP521_AES256GCM_SHA512_P521",
    "MLS_256_DHKEMX448_CHACHA20POLY1305_SHA512_Ed448",
    "MLS_256_DHKEMP384_AES256GCM_SHA384_P384",
    "MLS_128_X25519KYBER768DRAFT00_AES128GCM_SHA256_Ed25519"
};

enum MlsCredentialType {
    "Basic",
    "X509",
};

[Error]
enum CryptoError {
    "ConversationNotFound",
    "ConversationAlreadyExists",
    "ClientNotFound",
    "PendingProposalNotFound",
    "PendingCommitNotFound",
    "MalformedIdentifier",
    "ClientSignatureNotFound",
    "LockPoisonError",
    "ImplementationError",
    "OutOfKeyPackage",
    "MlsProviderError",
    "KeyStoreError",
    "MlsError",
    "Utf8Error",
    "StringUtf8Error",
    "ParseIntError",
    "ConvertIntError",
    "InvalidByteArrayError",
    "IoError",
    "Unauthorized",
    "CallbacksNotSet",
    "UnauthorizedExternalAddProposal",
    "UnauthorizedExternalCommit",
    "InvalidHashReference",
    "DuplicateMessage",
    "WrongEpoch",
    "BufferedFutureMessage",
    "DecryptionError",
    "HexDecodeError",
    "ProteusError",
    "CryptoboxMigrationError",
    "ProteusNotInitialized",
    "ProteusSupportNotEnabled",
    "MlsNotInitialized",
    "InvalidKeyPackage",
    "IdentityAlreadyPresent",
    "NoProvisionalIdentityFound",
    "TooManyIdentitiesPresent",
    "ParentGroupNotFound",
    "InvalidIdentity",
    "IdentityInitializationError",
    "MessageEpochTooOld",
    "E2eiEnrollmentNotDone",
    "CredentialNotFound",
    "InternalMlsError",
    "ClearingPendingCommitError",
    "SelfCommitIgnored",
    "UnmergedPendingGroup",
    "X509CertDerError",
    "PemError",
    "DomainNameNotFound",
    "DomainNamesDontMatch",
    "DuplicateDomainName",
    "InvalidCertificateChain",
    "EmptyTrustAnchorUpdate",
    "DuplicateCertificateChain",
    "OrphanWelcome",
};

enum MlsWirePolicy {
    "Plaintext",
    "Ciphertext",
};

[Error]
enum E2eIdentityError {
    "ImplementationError",
    "NotYetSupported",
    "E2eiInvalidDomain",
    "CryptoError",
    "IdentityError",
    "UrlError",
    "JsonError",
    "Utf8Error",
    "MlsError",
    "LockPoisonError",
};

enum E2eiConversationState {
    "Verified",
    "Degraded",
    "NotEnabled",
};

callback interface CoreCryptoCallbacks {
    boolean authorize([ByRef] bytes conversation_id, [ByRef] ClientId client_id);
    boolean user_authorize([ByRef] bytes conversation_id, [ByRef] ClientId external_client_id, [ByRef] sequence<ClientId> existing_clients);
    boolean client_is_existing_group_user([ByRef] bytes conversation_id, [ByRef] ClientId client_id, [ByRef] sequence<ClientId> existing_clients, [ByRef] sequence<ClientId>? parent_conversation_clients);
};

namespace CoreCrypto {
    string version();
};

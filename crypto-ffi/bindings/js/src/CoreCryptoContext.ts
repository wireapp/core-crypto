import {
    Ciphersuite,
    ClientId,
    ConversationId,
    CoreCryptoContext as CoreCryptoContextFfi,
    CredentialRef,
    CredentialType,
    ExternalSenderKey,
} from "./autogenerated/core_crypto_ffi";
import * as CoreCryptoFfiTypes from "./autogenerated/core_crypto_ffi";

export interface CredentialFindFilters {
    clientId?: ClientId;
    publicKey?: ArrayBuffer;
    ciphersuite?: Ciphersuite;
    credentialType?: CredentialType;
    earliestValidity?: bigint;
}

export class CoreCryptoContext extends CoreCryptoContextFfi {
    /** @internal */
    constructor(ctx: CoreCryptoContextFfi) {
        super(ctx);
    }

    /** @internal */
    static instanceOf(obj: unknown): obj is CoreCryptoContextFfi {
        return super.instanceOf(obj);
    }

    /**
     * Use this after initializing {@link CoreCrypto} when you have a clientId. It initializes MLS.
     * Registers the transport callbacks for core crypto to give it access to backend endpoints for sending
     * a commit bundle or a message, respectively.
     *
     * @param clientId - required
     * @param transport - Any implementor of the {@link MlsTransport} interface
     */

    /** @internal */
    async mlsInit(
        clientId: ClientId,
        transport: CoreCryptoFfiTypes.MlsTransport,
        asyncOpts_?: { signal: AbortSignal }
    ): Promise<void> {
        super.mlsInit(clientId, transport, asyncOpts_);
    }

    /**
     * Get those credentials known to this instance which match the provided filters
     *
     * @param findFilters a set of filters defining which credentials are of interest.
     */
    async getFilteredCredentials(
        findFilters: CredentialFindFilters
    ): Promise<CredentialRef[]> {
        return await super.findCredentials(
            findFilters.clientId,
            findFilters.publicKey,
            findFilters.ciphersuite,
            findFilters.credentialType,
            findFilters.earliestValidity
        );
    }

    /**
     * You should use {@link CoreCryptoContext.getFilteredCredentials} instead, since it provides a nicer interface.
     */
    async findCredentials(
        clientId?: ClientId,
        publicKey?: ArrayBuffer,
        ciphersuite?: Ciphersuite,
        credentialType?: CredentialType,
        earliestValidity?: bigint,
        asyncOpts_?: { signal: AbortSignal }
    ): Promise<Array<CredentialRef>> {
        return await super.findCredentials(
            clientId,
            publicKey,
            ciphersuite,
            credentialType,
            earliestValidity,
            asyncOpts_
        );
    }

    async createConversation(
        conversationId: ConversationId,
        credentialRef: CredentialRef,
        externalSender?: ExternalSenderKey,
        asyncOpts_?: { signal: AbortSignal }
    ): Promise<void> {
        return await super.createConversation(
            conversationId,
            credentialRef,
            externalSender,
            asyncOpts_
        );
    }
}

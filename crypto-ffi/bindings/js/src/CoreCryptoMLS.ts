import {
    CommitBundle,
    CredentialType,
    DeviceStatus,
    MlsGroupInfoEncryptionType as GroupInfoEncryptionType,
    MlsRatchetTreeType as RatchetTreeType,
    type MlsTransport as MlsTransportFfi,
    type MlsTransportData as MlsTransportDataFfi,
    MlsTransportResponse as MlsTransportResponseFfi,
    WelcomeBundle,
    WirePolicy,
    HistorySecret,
} from "./autogenerated/core_crypto_ffi";

export {
    CredentialType,
    DeviceStatus,
    GroupInfoEncryptionType,
    RatchetTreeType,
    WelcomeBundle,
    WirePolicy,
};

/**
 * Alias for proposal reference. It is a byte array of size 16.
 */
export type ProposalRef = Uint8Array;

/**
 * Returned by {@link MlsTransport} callbacks.
 */
export type MlsTransportResponse =
    | "success"
    | "retry"
    | {
        /**
         * The message was rejected by the delivery service and there's no recovery.
         */
        abort: { reason: string };
    };

function mapTransportResponseToFfi(
    response: MlsTransportResponse
): MlsTransportResponseFfi {
    if (response === "success") {
        return MlsTransportResponseFfi.Success.new();
    }
    if (response === "retry") {
        return MlsTransportResponseFfi.Retry.new();
    }
    if (response?.abort?.reason !== undefined) {
        return MlsTransportResponseFfi.Abort.new({ reason: response.abort.reason });
    }
    throw new Error(
        `Invalid MlsTransportResponse returned from callback: ${response}
         Not a member of the MlsTransportResponse type.`
    );
}

/**
 * An interface that must be implemented and provided to CoreCrypto via
 * {@link CoreCrypto.provideTransport}.
 */
export interface MlsTransport {
    /**
     * This callback is called by CoreCrypto to send a commit bundle to the delivery service.
     *
     * @param commitBundle - the commit bundle
     * @returns a promise resolving to a {@link MlsTransportResponse}
     */
    sendCommitBundle: (
        commitBundle: CommitBundle
    ) => Promise<MlsTransportResponse>;

    /**
     *  This callback is called by CoreCrypto to send a regular message to the delivery service.
     * @param message
     * @returns a promise resolving to a {@link MlsTransportResponse}
     */
    sendMessage: (message: ArrayBuffer) => Promise<MlsTransportResponse>;

    /**
     *  This callback is called by CoreCrypto to prepare a history secret to be sent to the delivery service.
     * @param secret
     * @returns a promise resolving to a {@link MlsTransportData}
     */
    prepareForTransport: (
        secret: HistorySecret
    ) => Promise<MlsTransportDataFfi>;
}

/**
 * This shim wraps an `MlsTransport` according to our public API and implements the inner FFI transport API,
 * mapping appropriately between the two.
 */
class MlsTransportFfiShim implements MlsTransportFfi {
    private inner: MlsTransport;

    constructor(inner: MlsTransport) {
        this.inner = inner;
    }

    async sendCommitBundle(
        commitBundle: CommitBundle
    ): Promise<MlsTransportResponseFfi> {
        const response = await this.inner.sendCommitBundle(commitBundle);
        return mapTransportResponseToFfi(response);
    }

    async sendMessage(message: ArrayBuffer): Promise<MlsTransportResponseFfi> {
        const response = await this.inner.sendMessage(message);
        return mapTransportResponseToFfi(response);
    }

    async prepareForTransport(
        secret: HistorySecret
    ): Promise<MlsTransportDataFfi> {
        return await this.inner.prepareForTransport(secret);
    }
}

export function mlsTransportToFfi(mlsTransport: MlsTransport): MlsTransportFfi {
    return new MlsTransportFfiShim(mlsTransport);
}

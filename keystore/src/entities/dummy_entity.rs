use std::{borrow::Borrow, collections::HashSet, sync::LazyLock};

use async_lock::RwLock;
use sha2::{Digest as _, Sha256};

#[cfg(not(target_family = "wasm"))]
use crate::connection::TransactionWrapper;
use crate::{
    CryptoKeystoreResult, MissingKeyErrorKind,
    entities::{Entity, EntityBase, EntityFindParams, StringEntityId},
    traits::{
        BorrowPrimaryKey, DecryptData as _, Decryptable, Decrypting, EncryptData as _, Encrypting, Entity as NewEntity,
        EntityBase as NewEntityBase, EntityDatabaseMutation, EntityDeleteBorrowed, KeyType,
    },
};

#[derive(Debug, Eq, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct DummyStoreValue;

#[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
impl EntityBase for DummyStoreValue {
    type ConnectionType = crate::connection::KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "";

    fn to_missing_key_err_kind() -> MissingKeyErrorKind {
        MissingKeyErrorKind::PersistedMlsGroup
    }

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        unimplemented!("Not implemented")
    }
}

#[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
impl Entity for DummyStoreValue {
    fn id_raw(&self) -> &[u8] {
        b""
    }

    async fn find_all(_conn: &mut Self::ConnectionType, _params: EntityFindParams) -> CryptoKeystoreResult<Vec<Self>> {
        Ok(vec![])
    }

    async fn find_one(_conn: &mut Self::ConnectionType, _id: &StringEntityId) -> CryptoKeystoreResult<Option<Self>> {
        Ok(Some(DummyStoreValue))
    }

    async fn find_many(conn: &mut Self::ConnectionType, ids: &[StringEntityId]) -> CryptoKeystoreResult<Vec<Self>> {
        // Default, inefficient & naive method
        let mut ret = Vec::with_capacity(ids.len());
        for id in ids {
            if let Some(entity) = Self::find_one(conn, id).await? {
                ret.push(entity);
            }
        }

        Ok(ret)
    }

    async fn count(_conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<usize> {
        Ok(0)
    }

    #[cfg(target_family = "wasm")]
    fn encrypt(&mut self, _cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        Ok(())
    }

    #[cfg(target_family = "wasm")]
    fn decrypt(&mut self, _cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DummyValue(Vec<u8>);

impl From<&str> for DummyValue {
    fn from(id: &str) -> Self {
        DummyValue(format!("dummy value {id}").into_bytes())
    }
}

static NEW_DUMMY_STORE_IDS: LazyLock<RwLock<HashSet<Vec<u8>>>> = LazyLock::new(|| {
    let mut results = HashSet::with_capacity(42);
    let mut hasher = Sha256::new();
    for idx in 0_u8..42 {
        hasher.update("NewEntity for NewDummyStoreValue: ".as_bytes());
        hasher.update(idx.to_be_bytes());

        results.insert(hasher.finalize_reset().as_slice().to_owned());
    }
    RwLock::new(results)
});

/// This struct is intended as a testbed for implementation of new entity traits.
///
/// It's mainly to confirm that it is possible to implement the traits as designed for a semi-realistic type.
pub struct NewDummyStoreValue {
    id: Vec<u8>,
    data: Vec<u8>,
}

impl NewDummyStoreValue {
    fn from_id(id: impl AsRef<[u8]>) -> Self {
        let id = id.as_ref().to_owned();
        let data = id.iter().copied().rev().collect();
        Self { id, data }
    }
}

impl NewEntityBase for NewDummyStoreValue {
    type ConnectionType = crate::connection::KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "dummy_store";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        unimplemented!("Not implemented")
    }
}

#[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
impl NewEntity for NewDummyStoreValue {
    type PrimaryKey = Vec<u8>;

    fn primary_key(&self) -> Vec<u8> {
        self.id.clone()
    }

    async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CryptoKeystoreResult<Option<Self>> {
        Self::get_borrowed(conn, key).await
    }

    /// Count the number of entities of this type in the database.
    async fn count(_conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        let guard = NEW_DUMMY_STORE_IDS.read().await;
        Ok(guard.len() as _)
    }

    /// Retrieve all entities of this type from the database.
    async fn load_all(_conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        let guard = NEW_DUMMY_STORE_IDS.read().await;
        let all = guard.iter().map(Self::from_id).collect();
        Ok(all)
    }
}

#[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
impl BorrowPrimaryKey for NewDummyStoreValue {
    type BorrowedPrimaryKey = [u8];

    fn borrow_primary_key(&self) -> &Self::BorrowedPrimaryKey {
        &self.id
    }

    async fn get_borrowed<Q>(_conn: &mut Self::ConnectionType, key: &Q) -> CryptoKeystoreResult<Option<Self>>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        let guard = NEW_DUMMY_STORE_IDS.read().await;
        let key = key.bytes();
        let key = key.as_ref();
        let value = guard.contains::<[u8]>(key).then(|| Self::from_id(key));
        Ok(value)
    }
}

#[cfg(not(target_family = "wasm"))]
#[async_trait::async_trait]
impl<'a> EntityDatabaseMutation<'a> for NewDummyStoreValue {
    type Transaction = TransactionWrapper<'a>;

    /// Use the transaction's interface to save this entity to the database
    async fn save(&self, _tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        let mut guard = NEW_DUMMY_STORE_IDS.write().await;
        guard.insert(self.primary_key());
        Ok(())
    }

    /// Use the transaction's interface to count the number of entities of this type in the database.
    async fn count(_tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        let guard = NEW_DUMMY_STORE_IDS.read().await;
        Ok(guard.len() as _)
    }

    /// Use the transaction's inteface to delete this entity from the database.
    ///
    /// Returns `true` if at least one entity was deleted, or `false` if the id was not found in the database.
    ///
    /// For entites whose primary key has a distinct borrowed type, it is best to implement this as a direct
    /// passthrough:
    ///
    /// ```rust,ignore
    /// async fn delete(tx: &Self::Transaction, key: &Self::PrimaryKey) -> CoreCryptoKeystoreResult<bool> {
    ///     <Self as EntityTransactionDeleteBorrowed<'a>>::delete_borrowed(tx, id).await
    /// }
    /// ```
    async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> CryptoKeystoreResult<bool> {
        Self::delete_borrowed(tx, id).await
    }
}

#[cfg(not(target_family = "wasm"))]
#[async_trait::async_trait]
impl EntityDeleteBorrowed<'_> for NewDummyStoreValue {
    /// Delete an entity by a borrowed form of its primary key.
    async fn delete_borrowed<Q>(_tx: &Self::Transaction, id: &Q) -> CryptoKeystoreResult<bool>
    where
        Self::PrimaryKey: Borrow<Q>,
        Q: KeyType,
    {
        let mut guard = NEW_DUMMY_STORE_IDS.write().await;
        let removed = guard.remove::<[u8]>(id.bytes().as_ref());
        Ok(removed)
    }
}

#[derive(serde::Deserialize)]
pub struct NewDummyStoreValueDecrypt<'a> {
    id: Vec<u8>,
    sensitive_data: &'a [u8],
}

impl<'a> Decrypting<'a> for NewDummyStoreValueDecrypt<'a> {
    type DecryptedForm = NewDummyStoreValue;

    fn decrypt(self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<NewDummyStoreValue> {
        let id = self.id;
        let data = NewDummyStoreValue::decrypt_data(cipher, &id, self.sensitive_data)?;
        Ok(NewDummyStoreValue { id, data })
    }
}

impl<'a> Decryptable<'a> for NewDummyStoreValue {
    type DecryptableFrom = NewDummyStoreValueDecrypt<'a>;
}

#[derive(serde::Serialize)]
pub struct NewDummyStoreValueEncrypt<'a> {
    id: &'a Vec<u8>,
    data: Vec<u8>,
}

impl<'a> Encrypting<'a> for NewDummyStoreValue {
    type EncryptedForm = NewDummyStoreValueEncrypt<'a>;

    fn encrypt(&'a self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::EncryptedForm> {
        let id = &self.id;
        let data = self.encrypt_data(cipher, &self.data)?;
        Ok(NewDummyStoreValueEncrypt { id, data })
    }
}

/// Testbed for deriving the new entity traits.
///
/// Demonstrates a few things:
///
/// 1. Derivation works properly
/// 2. Derivation does not depend on any particular symbols existing in the namespace.
/// 3. Derivation produces equivalent code to a manual implementation.
///
/// To validate these properties, uncomment the relevant struct, and run:
///
/// ```sh
///  cargo expand -p core-crypto-keystore --features dummy-entity entities::dummy_entity::derive
/// ```
///
/// Note that none of these will actually build correctly right now, because none of them have
/// variants in the dynamic dispatch enum. This is why they're all commented out by default.
mod derive {
    // test a very simple entity
    // #[derive(core_crypto_macros::EntityNew)]
    // struct SimpleEntity {
    //     id: Vec<u8>,
    //     data: Vec<u8>,
    // }

    // test an entity which has an explicitly-set id
    // #[derive(core_crypto_macros::EntityNew)]
    // struct ExplicitId {
    //     #[entity(id)]
    //     not_named_id: Vec<u8>,
    // }

    // test an entity which has several fields of various types
    // #[derive(core_crypto_macros::EntityNew)]
    // struct MultiFieldEntity {
    //     id: String,
    //     bytes_value: Vec<u8>,
    //     string_value: String,
    //     optional_value: Option<Vec<u8>>,
    // }

    // test an entity which has an explicit collection name and some more complicated fields
    // #[derive(core_crypto_macros::EntityNew)]
    // #[entity(collection_name = "complex_entities")]
    // struct ComplexEntity {
    //     #[entity(id, hex, column = "id_hex")]
    //     key: Vec<u8>,
    //     #[entity(hex)]
    //     hex_data: Vec<u8>,
    //     #[entity(column = "renamed_column")]
    //     rename_me: Vec<u8>,
    // }
}

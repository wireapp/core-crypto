// This module exists so we can use Typescript to review how our mls functions should look in `mod.rs`.
//
// While this is a Typescript file, use care to write the function bodies in pure Javascript.
// They will be copied directly into the JS environment without any transpilation!
// Even so, just having the definitions written in this file instead of as string literals
// means that TSC can help us out in case we're using the interface wrong.
//
// Note in particular that functions _must not_ use a normal parameters list. Instead they must
// internally destructure the `arguments` list. This is to conform with the webdriver `.execute` API.

import { Ciphersuite, CoreCrypto, CredentialType, MlsTransport, MlsTransportData } from "./corecrypto.js";

declare global {
    interface Window {
        CoreCrypto: typeof CoreCrypto;
        cc: CoreCrypto;
        ciphersuite: Ciphersuite;
        credentialType: CredentialType;
        deliveryService: MlsTransport;
    }
}

export async function ccNew() {
    const { CoreCrypto, ClientId, CredentialType, DatabaseKey, initWasmModule, openDatabase, ciphersuiteFromU16 } = await import("./corecrypto.js");
    await initWasmModule("autogenerated/");

    let [clientConfig] = arguments;
    clientConfig.clientId = new ClientId(new TextEncoder().encode(clientConfig.clientId))
    clientConfig.ciphersuites = clientConfig.ciphersuites.map((n) => ciphersuiteFromU16(n))

    const keyBytes = new Uint8Array(32);
    window.crypto.getRandomValues(keyBytes);
    const key = new DatabaseKey(keyBytes);
    const database = await openDatabase(clientConfig.databaseName, key);
    clientConfig.database = database;

    window.CoreCrypto = CoreCrypto;
    window.cc = await window.CoreCrypto.init(clientConfig);
    window.ciphersuite = clientConfig.ciphersuites[0];
    window.credentialType = CredentialType.Basic;

    window.deliveryService = {
        async sendCommitBundle() {
            return "success";
        },
        async sendMessage() {
            return "success";
        },
        async prepareForTransport(secret) {
            return new MlsTransportData(secret.data)
        }
    };

    await window.cc.provideTransport(window.deliveryService);
}

export async function getKeypackage() {
    const [kp] = await window.cc.transaction((ctx) =>
        ctx.clientKeypackages(window.ciphersuite, window.credentialType, 1)
    );
    return kp;
}

export async function addClient() {
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, kp] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const keyPackage = Uint8Array.from(Object.values(kp));

    if (!window.cc.conversationExists(conversationId)) {
        await window.cc.transaction((ctx) =>
            ctx.createConversation(conversationId, window.credentialType, { ciphersuite: window.ciphersuite })
        );
    }
    await window.cc.transaction((ctx) =>
        ctx.addClientsToConversation(conversationId, [keyPackage]));
}

export async function kickClient() {
    const { ConversationId, ClientId } = await import("./corecrypto.js");
    const [cId, clId] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const clientId = new ClientId(Uint8Array.from(Object.values(clId)));
    await window.cc.transaction((ctx) =>
        ctx.removeClientsFromConversation(conversationId, [clientId]));
}

export async function processWelcome() {
    const { Welcome } = await import("./corecrypto.js");
    const [welcome] = arguments;
    const welcomeMessage = new Welcome(Uint8Array.from(Object.values(welcome)));

    const { id } = await window.cc.transaction((ctx) =>
        ctx.processWelcomeMessage(welcomeMessage));
    return id.copyBytes();
}

export async function encryptMessage() {
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, cleartext] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const message = Uint8Array.from(Object.values(cleartext));

    return await window.cc.transaction((ctx) =>
        ctx.encryptMessage(conversationId, message));
}

export async function decryptMessage() {
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, encMessage] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const encryptedMessage = Uint8Array.from(Object.values(encMessage));

    const { message } = await window.cc.transaction((ctx) =>
        ctx.decryptMessage(conversationId, encryptedMessage)
    );
    return message;
}

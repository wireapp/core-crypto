use std::{
    borrow::Cow,
    collections::{HashMap, HashSet, hash_map::Entry},
    iter::Cloned,
    sync::Arc,
};

use async_lock::SemaphoreGuardArc;
use itertools::Itertools;
use tokio::sync::{OwnedRwLockWriteGuard, RwLock, RwLockMappedWriteGuard, RwLockWriteGuard};

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult,
    connection::{Database, KeystoreDatabaseConnection},
    entities::{MlsPendingMessage, PersistedMlsGroup},
    traits::{
        BorrowPrimaryKey, Entity, EntityBase as _, EntityDatabaseMutation, EntityDeleteBorrowed, KeyType,
        SearchableEntity,
    },
    transaction::dynamic_dispatch::EntityId,
};

pub(crate) mod dynamic_dispatch;

/// table: primary key -> entity reference
///
/// The inner value is an option: `None` represents a deletion, `Some()` represents an upsert. Accordingly, those
/// operations will be executed when the transaction is finished.
type InMemoryTable = HashMap<EntityId, Arc<RwLock<Option<dynamic_dispatch::Entity>>>>;
/// collection: collection name -> table
type InMemoryCollection = Arc<RwLock<HashMap<&'static str, InMemoryTable>>>;

/// This represents a transaction, where all operations will be done in memory and committed at the
/// end
#[derive(Debug, Clone)]
pub(crate) struct KeystoreTransaction {
    cache: InMemoryCollection,
    _semaphore_guard: Arc<SemaphoreGuardArc>,
}

impl KeystoreTransaction {
    /// Instantiate a new transaction.
    ///
    /// Requires a semaphore guard to ensure that only one exists at a time.
    pub(crate) async fn new(semaphore_guard: SemaphoreGuardArc) -> CryptoKeystoreResult<Self> {
        Ok(Self {
            cache: Default::default(),
            _semaphore_guard: Arc::new(semaphore_guard),
        })
    }

    /// Save an entity into this transaction.
    ///
    /// This is a multi-step process:
    ///
    /// - Adjust the entity by calling its [`pre_save()`][Entity::pre_save] method.
    /// - Store the entity in an internal map.
    ///   - Remove the entity from the set of deleted entities, if it was there.
    /// - On [`Self::commit`], actually persist the entity into the supplied database.
    pub(crate) async fn save<'a, E>(&self, mut entity: E) -> CryptoKeystoreResult<E::AutoGeneratedFields>
    where
        E: Entity<ConnectionType = KeystoreDatabaseConnection> + EntityDatabaseMutation<'a> + Send + Sync,
    {
        let auto_generated_fields = entity.pre_save().await?;

        let entity_id =
            EntityId::from_entity(&entity).ok_or(CryptoKeystoreError::UnknownCollectionName(E::COLLECTION_NAME))?;

        self.delete_or_save(entity_id, Some(entity)).await?;

        Ok(auto_generated_fields)
    }

    async fn remove_by_entity_id<'a, E>(&self, entity_id: EntityId) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        // rm this entity from the set of added/modified items
        // it might never touch the real db at all
        // start by adding the entity
        self.delete_or_save::<E>(entity_id, None).await
    }

    async fn delete_or_save<'a, E>(&self, entity_id: EntityId, entity: Option<E>) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        let mut cache_guard = self.cache.write().await;
        let table = cache_guard.entry(E::COLLECTION_NAME).or_default();
        let transaction_entity = entity.map(|e| e.to_transaction_entity());

        if let Some(entity_lock) = table.get(&entity_id).cloned() {
            let mut guard = entity_lock.write().await;
            *guard = transaction_entity;
        } else {
            let entry = Arc::new(RwLock::new(transaction_entity));
            table.insert(entity_id.clone(), entry);
        };
        Ok(())
    }

    /// Remove an entity by its primary key.
    ///
    /// Where the primary key has a distinct borrowed form, consider [`Self::remove_borrowed`].
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove<'a, E>(&self, id: &E::PrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        let entity_id = EntityId::from_primary_key::<E>(id)
            .ok_or(CryptoKeystoreError::UnknownCollectionName(E::COLLECTION_NAME))?;
        self.remove_by_entity_id::<E>(entity_id).await
    }

    /// Remove an entity by the borrowed form of its primary key.
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove_borrowed<'a, E>(&self, id: &E::BorrowedPrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: EntityDeleteBorrowed<'a> + BorrowPrimaryKey,
    {
        let entity_id = EntityId::from_borrowed_primary_key::<E>(id)
            .ok_or(CryptoKeystoreError::UnknownCollectionName(E::COLLECTION_NAME))?;
        self.remove_by_entity_id::<E>(entity_id).await
    }

    pub(crate) async fn child_groups(
        &self,
        entity: PersistedMlsGroup,
        persisted_records: impl IntoIterator<Item = PersistedMlsGroup>,
    ) -> CryptoKeystoreResult<Vec<PersistedMlsGroup>> {
        // First get all raw groups from the cache, then filter by their parent id
        let cached_records = self.find_all_in_cache::<PersistedMlsGroup>().await;
        let cached_records = cached_records
            .iter()
            .filter(|maybe_child| {
                maybe_child
                    .parent_id
                    .as_deref()
                    .map(|parent_id| parent_id == entity.borrow_primary_key().bytes().as_ref())
                    .unwrap_or_default()
            })
            .map(Arc::as_ref)
            .map(Cow::Borrowed);

        let persisted_records = persisted_records.into_iter().map(Cow::Owned);

        Ok(self.merge_records(cached_records, persisted_records).await)
    }

    pub(crate) async fn remove_pending_messages_by_conversation_id(&self, conversation_id: impl AsRef<[u8]> + Send) {
        let conversation_id = conversation_id.as_ref();

        let mut cache_guard = self.cache.write().await;
        if let Entry::Occupied(mut pending_messages_table) = cache_guard.entry(MlsPendingMessage::COLLECTION_NAME) {
            for (_, dyn_entity) in pending_messages_table.get_mut().iter() {
                let entity_guard = dyn_entity.read().await;
                let pending_message = entity_guard.as_ref().map(|entity| {
                    entity
                        .downcast::<MlsPendingMessage>()
                        .expect("table for MlsPendingMessage contains only that type")
                });

                if let Some(pending_message) = pending_message
                    && pending_message.foreign_id == conversation_id
                {
                    // upgrade lock
                    drop(entity_guard);
                    let mut pending_message = dyn_entity.write().await;
                    *pending_message = None;
                }
            }
        }
    }

    pub(crate) async fn find_pending_messages_by_conversation_id(
        &self,
        conversation_id: &[u8],
        persisted_records: impl IntoIterator<Item = MlsPendingMessage>,
    ) -> CryptoKeystoreResult<Vec<MlsPendingMessage>> {
        let persisted_records = persisted_records.into_iter().map(Cow::Owned);

        let cached_records = self.find_all_in_cache::<MlsPendingMessage>().await;
        let cached_records = cached_records
            .iter()
            .filter(|pending_message| pending_message.foreign_id == conversation_id)
            .map(Arc::as_ref)
            .map(Cow::Borrowed);

        let merged_records = self.merge_records(cached_records, persisted_records).await;
        Ok(merged_records)
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    async fn get_by_entity_id<E>(&self, entity_id: &EntityId) -> Option<RwLockMappedWriteGuard<Option<E>>>
    where
        E: Entity + Send + Sync,
    {
        let cache_guard = self.cache.read().await;
        let table = cache_guard.get(E::COLLECTION_NAME)?;
        if let Some(entity) = table.get(entity_id) {
            let entity_guard = entity.write().await;
            RwLockWriteGuard::map(entity_guard, |e| {})
        }
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get<E>(&self, id: &E::PrimaryKey) -> Option<Option<Arc<E>>>
    where
        E: Entity + Send + Sync,
    {
        let entity_id = EntityId::from_primary_key::<E>(id)?;
        self.get_by_entity_id(&entity_id).await
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get_borrowed<E>(&self, id: &E::BorrowedPrimaryKey) -> Option<Option<Arc<E>>>
    where
        E: Entity + BorrowPrimaryKey + Send + Sync,
    {
        let entity_id = EntityId::from_borrowed_primary_key::<E>(id)?;
        self.get_by_entity_id(&entity_id).await
    }

    async fn find_all_in_cache<E>(&self) -> Vec<Arc<E>>
    where
        E: Entity + Send + Sync,
    {
        let cache_guard = self.cache.read().await;
        cache_guard
            .get(E::COLLECTION_NAME)
            .map(|table| {
                table
                    .values()
                    .map(|record: &dynamic_dispatch::Entity| {
                        record
                            .downcast::<E>()
                            .expect("all entries in this table are of this type")
                            .clone()
                    })
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default()
    }

    async fn search_in_cache<E, SearchKey>(&self, search_key: &SearchKey) -> Vec<Arc<E>>
    where
        E: Entity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        let cache_guard = self.cache.read().await;
        cache_guard
            .get(E::COLLECTION_NAME)
            .map(|table| {
                table
                    .values()
                    .filter_map(|record: &dynamic_dispatch::Entity| {
                        let entity = record
                            .downcast::<E>()
                            .expect("all entries in this table are of this type")
                            .clone();
                        entity.matches(search_key).then_some(entity)
                    })
                    .collect()
            })
            .unwrap_or_default()
    }

    pub(crate) async fn find_all<E>(&self, persisted_records: Vec<E>) -> CryptoKeystoreResult<Vec<E>>
    where
        E: Clone + Entity + Send + Sync,
    {
        let cached_records = self.find_all_in_cache().await;
        let merged_records = self
            .merge_records(
                cached_records.iter().map(Arc::as_ref).map(Cow::Borrowed),
                persisted_records.into_iter().map(Cow::Owned),
            )
            .await;
        Ok(merged_records)
    }

    pub(crate) async fn search<E, SearchKey>(
        &self,
        persisted_records: Vec<E>,
        search_key: &SearchKey,
    ) -> CryptoKeystoreResult<Vec<E>>
    where
        E: Clone + Entity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        let cached_records = self.search_in_cache(search_key).await;
        let merged_records = self
            .merge_records(
                cached_records.iter().map(Arc::as_ref).map(Cow::Borrowed),
                persisted_records.into_iter().map(Cow::Owned),
            )
            .await;
        Ok(merged_records)
    }

    /// Build a single list of unique records from two potentially overlapping lists.
    /// In case of overlap, records in `records_a` are prioritized.
    /// Identity from the perspective of this function is determined by the output of
    /// [Entity::merge_key].
    ///
    /// Further, the output list of records is built with respect to the provided [EntityFindParams]
    /// and the deleted records cached in this [Self] instance.
    async fn merge_records<'a, E>(
        &self,
        records_a: impl IntoIterator<Item = Cow<'a, E>>,
        records_b: impl IntoIterator<Item = Cow<'a, E>>,
    ) -> Vec<E>
    where
        E: Clone + Entity,
    {
        let deleted_records = self.deleted.read().await;

        records_a
            .into_iter()
            .chain(records_b)
            .unique_by(|e| e.primary_key().bytes().into_owned())
            .filter_map(|record| {
                let id = EntityId::from_entity(record.as_ref())?;
                (!deleted_records.contains(&id)).then_some(record.into_owned())
            })
            .collect()
    }

    /// Persists all the operations in the database. It will effectively open a transaction
    /// internally, perform all the buffered operations and commit.
    pub(crate) async fn commit(&self, db: &Database) -> Result<(), CryptoKeystoreError> {
        let conn = db.conn().await?;
        let mut conn = conn.conn().await;

        let cache = self.cache.read().await;
        let deleted_ids = self.deleted.read().await;

        let table_names_with_deletion = deleted_ids.iter().map(|entity_id| entity_id.collection_name());
        let table_names_with_save = cache
            .values()
            .flat_map(|table| table.keys())
            .map(|entity_id| entity_id.collection_name());
        let mut tables = table_names_with_deletion
            .chain(table_names_with_save)
            .collect::<Vec<_>>();

        if tables.is_empty() {
            log::debug!("Empty transaction was committed.");
            return Ok(());
        }

        tables.sort_unstable();
        tables.dedup();

        // open a database transaction
        #[cfg(target_family = "wasm")]
        let tx = conn.new_transaction(&tables).await?;
        #[cfg(not(target_family = "wasm"))]
        let tx = conn.transaction()?.into();

        for entity in cache.values().flat_map(|table| table.values()) {
            entity.execute_save(&tx).await?;
        }

        for deleted_id in deleted_ids.iter() {
            deleted_id.execute_delete(&tx).await?;
        }

        // and commit everything
        tx.commit_tx().await?;

        Ok(())
    }
}

use rusqlite::{Row, ToSql};

use super::super::{count_helper, get_helper, load_all_helper};
use crate::{
    CryptoKeystoreResult, Entity, EntityBase, EntityTransactionExt,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::ProteusPrekey,
};

#[async_trait::async_trait]
impl EntityBase for ProteusPrekey {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "proteus_prekeys";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::ProteusPrekey(self)
    }
}

impl ProteusPrekey {
    fn from_row(row: &Row<'_>) -> rusqlite::Result<Self> {
        let id = row.get("id")?;
        let prekey = row.get("key")?;
        Ok(Self::from_raw(id, prekey))
    }
}

#[async_trait::async_trait]
impl Entity for ProteusPrekey {
    /// Each distinct [`PrimaryKey`] uniquely identifies either 0 or 1 instance.
    ///
    /// This constraint should be enforced at the DB level.
    type PrimaryKey = u16;

    /// Get this entity's primary key.
    fn primary_key(&self) -> Self::PrimaryKey {
        self.id
    }

    /// Get an entity by its primary key.
    async fn get(conn: &mut Self::ConnectionType, id: &u16) -> CryptoKeystoreResult<Option<Self>> {
        get_helper(conn, "id", *id, Self::from_row).await
    }

    /// Count the number of entities of this type in the database.
    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        count_helper::<Self>(conn).await
    }

    /// Retrieve all entities of this type from the database.
    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        load_all_helper(conn, Self::from_row).await
    }
}

#[async_trait::async_trait]
impl<'a> EntityTransactionExt<'a> for ProteusPrekey {
    type Transaction = TransactionWrapper<'a>;

    /// Use the transaction's interface to count the number of entities of this type in the database.
    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        let mut statement = tx.prepare_cached("SELECT COUNT(*) FROM proteus_prekeys")?;
        let count = statement.query_one([], |row| row.get::<_, u32>(0))?;
        Ok(count)
    }

    /// Use the transaction's interface to save this entity to the database
    async fn save(&self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        // Use UPSERT (ON CONFLICT DO UPDATE)
        let sql = "
        INSERT INTO proteus_prekeys (id, key)
        VALUES (?, ?)
        ON CONFLICT(id) DO UPDATE SET key = excluded.key";

        let mut statement = tx.prepare_cached(sql)?;
        statement.execute([self.id.to_sql()?, self.prekey.to_sql()?])?;
        Ok(())
    }

    /// Use the transaction's inteface to delete this entity from the database.
    ///
    /// Returns `true` if at least one entity was deleted, or `false` if the id was not found in the database.
    async fn delete(tx: &Self::Transaction, id: &u16) -> CryptoKeystoreResult<bool> {
        let id = *id;
        let mut statement = tx.prepare_cached("DELETE FROM proteus_prekeys WHERE id = ?")?;
        let updated = statement.execute([id])?;
        Ok(updated > 0)
    }
}

use itertools::Itertools as _;
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{Ident, Lifetime};

use crate::entity_derive::{Entity, FieldTransformation, column_type::ColumnType};

impl quote::ToTokens for Entity {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.extend(self.impl_entity_base());
        tokens.extend(self.impl_primary_key());
        tokens.extend(self.impl_entity_generic());
        tokens.extend(self.impl_entity_wasm());
        tokens.extend(self.impl_entity_get_borrowed());
        tokens.extend(self.impl_entity_database_mutation());
        tokens.extend(self.impl_entity_delete_borrowed());
        tokens.extend(self.impl_decrypting());
        tokens.extend(self.impl_encrypting());
    }
}

impl Entity {
    /// `impl EntityBase for MyEntity`
    fn impl_entity_base(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            ..
        } = self;

        // Identical for both wasm and non-wasm
        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl crate::traits::EntityBase for #struct_name {
                type ConnectionType = crate::connection::KeystoreDatabaseConnection;
                type AutoGeneratedFields = ();
                const COLLECTION_NAME: &'static str = #collection_name;

                fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
                    crate::transaction::dynamic_dispatch::Entity::#struct_name(self.into())
                }

                fn get_in_memory_table() -> crate::transaction::InMemoryTableGuard<Self> {
                    static IN_MEMORY_TABLE: std::sync::OnceLock<crate::transaction::InMemoryTable<#struct_name>> = std::sync::OnceLock::new();
                    let table = IN_MEMORY_TABLE.get_or_init(Default::default);
                    table.upgradable_read_arc().await
                }
            }
        }
    }

    /// `impl PrimaryKey for MyEntity` and `impl BorrowPrimaryKey for MyEntity`
    fn impl_primary_key(&self) -> TokenStream {
        let Self {
            struct_name, id_column, ..
        } = self;

        let primary_key = id_column.column_type.owned();
        let borrowed_primary_key = id_column.column_type.borrowed();
        let pk_field_name = &id_column.field_name;

        quote! {
            impl crate::traits::PrimaryKey for #struct_name {
                type PrimaryKey = #primary_key;

                fn primary_key(&self) -> Self::PrimaryKey {
                    self.#pk_field_name.clone()
                }
            }

            impl crate::traits::BorrowPrimaryKey for #struct_name {
                type BorrowedPrimaryKey = #borrowed_primary_key;

                fn borrow_primary_key(&self) -> &Self::BorrowedPrimaryKey {
                    &self.#pk_field_name
                }
            }
        }
    }

    /// `#[cfg(not(target_family = "wasm"))] impl Entity for MyEntity`
    fn impl_entity_generic(&self) -> TokenStream {
        let Self {
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        quote! {
            #[cfg(not(target_family = "wasm"))]
            #[::async_trait::async_trait]
            impl crate::traits::Entity for #struct_name {
                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    <Self as crate::traits::EntityGetBorrowed>::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    crate::entities::platform::count_helper::<Self>(conn).await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    crate::entities::platform::load_all_helper::<Self, _>(conn, |row| {
                        Ok(Self {
                            #( #field_assignments, )*
                        })
                    }).await
                }
            }
        }
    }

    /// `#[cfg(target_family = "wasm")] impl Entity for MyEntity`
    fn impl_entity_wasm(&self) -> TokenStream {
        let Self { struct_name, .. } = self;

        quote! {
            #[cfg(target_family = "wasm")]
            #[::async_trait::async_trait(?Send)]
            impl crate::traits::Entity for #struct_name {
                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    <Self as crate::traits::EntityGetBorrowed>::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    conn.storage().count::<Self>().await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    conn.storage().get_all().await
                }
            }
        }
    }

    /// `impl EntityGetBorrowed for MyEntity`
    fn impl_entity_get_borrowed(&self) -> TokenStream {
        let Self {
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let pk_column_name = id_column
            .column_name
            .clone()
            .unwrap_or_else(|| id_column.field_name.to_string());

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        // if we ever add a second field transformation, we'll want this match pattern
        #[allow(clippy::manual_map)]
        let key_transform = match id_column.transformation {
            None => None,
            Some(FieldTransformation::Hex) => Some(quote! {
                #[cfg(not(target_family = "wasm"))]
                let key = hex::encode(key);
            }),
        };

        quote! {
            #[cfg_attr(target_family = "wasm", ::async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), ::async_trait::async_trait)]
            impl crate::traits::EntityGetBorrowed for #struct_name {
                async fn get_borrowed(conn: &mut Self::ConnectionType, key: &Self::BorrowedPrimaryKey)
                    -> crate::CryptoKeystoreResult<Option<Self>>
                {
                    let key = <&Self::BorrowedPrimaryKey as crate::traits::KeyType>::bytes(&key);
                    let key = key.as_ref();
                    #key_transform
                    #[cfg(target_family = "wasm")]
                    {
                        conn.storage().get(key).await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::get_helper::<Self, _>(conn, #pk_column_name, key, |row| {
                            Ok(Self {
                                #( #field_assignments, )*
                            })
                        }).await
                    }
                }
            }
        }
    }

    fn impl_entity_database_mutation(&self) -> TokenStream {
        let Self {
            upsert,
            collection_name,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let or_replace = upsert.then_some("OR REPLACE").unwrap_or_default();
        let sql_column_names = std::iter::once(id_column.sql_name())
            .chain(other_columns.iter().map(|column| column.sql_name()))
            .join(", ");
        let sql_field_placeholders = std::iter::repeat_n("?", other_columns.len() + 1).join(", ");
        let sql_statement = format!(
            "INSERT {or_replace} INTO {collection_name} ({sql_column_names}) VALUES ({sql_field_placeholders})"
        );
        let fields = std::iter::once(id_column.store_expression())
            .chain(other_columns.iter().map(|column| column.store_expression()))
            .map(|tokens| quote!(#tokens,))
            .collect::<TokenStream>();

        let sql_map_err = (!upsert).then_some(quote! {
            .map_err(|_| crate::CryptoKeystoreError::AlreadyExists(Self::COLLECTION_NAME))
        });

        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl<'a> crate::traits::EntityDatabaseMutation<'a> for #struct_name {
                type Transaction = crate::connection::TransactionWrapper<'a>;

                async fn save(&'a self, tx: &Self::Transaction) -> crate::CryptoKeystoreResult<()> {
                    #[cfg(target_family = "wasm")]
                        {
                            tx.save(self).await
                        }

                        #[cfg(not(target_family = "wasm"))]
                        {
                            let mut stmt = tx.prepare_cached(#sql_statement)?;
                            stmt.execute(rusqlite::params![#fields])#sql_map_err?;
                            Ok(())
                        }
                }

                async fn count(tx: &Self::Transaction) -> crate::CryptoKeystoreResult<u32> {
                    #[cfg(target_family = "wasm")]
                    {
                        tx.count::<Self>().await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::count_helper_tx::<Self>(tx).await
                    }
                }

                async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<bool> {
                    <Self as crate::traits::EntityDeleteBorrowed>::delete_borrowed(tx, id).await
                }
            }
        }
    }

    fn impl_entity_delete_borrowed(&self) -> TokenStream {
        let Self {
            struct_name, id_column, ..
        } = self;

        let id_column_name = id_column.sql_name();
        // if we ever add a second field transformation, we'll want this match pattern
        #[allow(clippy::manual_map)]
        let key_transform = match id_column.transformation {
            None => None,
            Some(FieldTransformation::Hex) => Some(quote! {
                #[cfg(not(target_family = "wasm"))]
                let key = hex::encode(key);
            }),
        };

        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl<'a> crate::traits::EntityDeleteBorrowed<'a> for #struct_name {
                async fn delete_borrowed(
                    tx: &<Self as crate::traits::EntityDatabaseMutation<'a>>::Transaction,
                    id: &<Self as crate::traits::BorrowPrimaryKey>::BorrowedPrimaryKey,
                ) -> crate::CryptoKeystoreResult<bool>
                where
                    for<'pk> &'pk <Self as crate::traits::BorrowPrimaryKey>::BorrowedPrimaryKey: crate::traits::KeyType,
                {
                    let key = <&<Self as crate::traits::BorrowPrimaryKey>::BorrowedPrimaryKey as crate::traits::KeyType>::bytes(&id);
                    let key = key.as_ref();
                    #key_transform
                    #[cfg(target_family = "wasm")]
                    {
                        tx.delete::<Self>(key).await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::delete_helper::<Self>(tx, #id_column_name, key).await
                    }
                }
            }
        }
    }

    fn impl_decrypting(&self) -> TokenStream {
        let Self {
            visibility,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let decrypt_struct_name = Ident::new(&format!("{struct_name}Decrypt"), Span::call_site());
        let field_name =
            std::iter::once(&id_column.field_name).chain(other_columns.iter().map(|column| &column.field_name));
        let field_type = std::iter::once(id_column.column_type.owned()).chain(
            other_columns
                .iter()
                .map(|column| column.column_type.encrypted_form().owned()),
        );

        let id_field_name = &id_column.field_name;
        // id field gets moved: no cloning!
        let id_field_assignment = quote!(#id_field_name: self.#id_field_name);

        let other_field_assignment = other_columns.iter().map(|column| {
            let field_name = &column.field_name;
            let make_decrypt_operation = |accessor: TokenStream| {
                if column.skip_encryption {
                    quote!(Ok::<_, crate::CryptoKeystoreError>(#accessor.to_owned()))
                } else {
                    quote!(
                        <#struct_name as crate::traits::DecryptData>::decrypt_data(
                            cipher,
                            &self.#id_field_name,
                            #accessor,
                        )
                    )
                }
            };
            let field_expr = match column.column_type {
                ColumnType::Bytes => {
                    let decrypt_operation = make_decrypt_operation(quote!(&self.#field_name));
                    quote!(#decrypt_operation?)
                }
                ColumnType::String => {
                    let decrypt_operation = make_decrypt_operation(quote!(&self.#field_name));
                    quote!(String::from_utf8(#decrypt_operation?).map_err(|err| err.utf8_error())?)
                }
                ColumnType::OptionalBytes => {
                    let decrypt_operation = make_decrypt_operation(quote!(#field_name));
                    quote!(self.#field_name.as_ref().map(|#field_name| #decrypt_operation).transpose()?)
                }
            };

            quote!(#field_name: #field_expr)
        });

        // id field gets moved _last_ so that we can borrow `self.id_field` for the `decrypt_data` calls
        let field_assignment = other_field_assignment.chain(std::iter::once(id_field_assignment));

        quote! {
            #[derive(serde::Deserialize)]
            #visibility struct #decrypt_struct_name {
                #( #field_name: #field_type, )*
            }

            impl crate::traits::Decrypting<'static> for #decrypt_struct_name {
                type DecryptedForm = #struct_name;

                fn decrypt(self, cipher: &aes_gcm::Aes256Gcm) -> crate::CryptoKeystoreResult<#struct_name> {
                    Ok(#struct_name {
                        #( #field_assignment, )*
                    })
                }
            }

            impl crate::traits::Decryptable<'static> for #struct_name {
                type DecryptableFrom = #decrypt_struct_name;
            }
        }
    }

    fn impl_encrypting(&self) -> TokenStream {
        let Self {
            visibility,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let encrypt_struct_name = Ident::new(&format!("{struct_name}Encrypt"), Span::call_site());
        let lifetime = Lifetime::new("'a", Span::call_site());
        let field_name =
            std::iter::once(&id_column.field_name).chain(other_columns.iter().map(|column| &column.field_name));
        let field_type = std::iter::once(id_column.column_type.borrowed_with_sigil(&lifetime)).chain(
            other_columns
                .iter()
                .map(|column| column.column_type.encrypted_form().owned()),
        );

        let id_field_name = &id_column.field_name;
        let id_field_assignment = quote!(#id_field_name: &self.#id_field_name);

        let other_field_assignment = other_columns.iter().map(|column| {
            let field_name = &column.field_name;
            let make_encrypt_operation = |accessor: TokenStream| {
                if column.skip_encryption {
                    quote!(Ok::<_, crate::CryptoKeystoreError>(#accessor.to_owned()))
                } else {
                    quote!(
                        <Self as crate::traits::EncryptData>::encrypt_data(
                            self,
                            cipher,
                            #accessor,
                        )
                    )
                }
            };
            let field_expr = match column.column_type {
                ColumnType::Bytes => {
                    let encrypt_operation = make_encrypt_operation(quote!(&self.#field_name));
                    quote!(#encrypt_operation?)
                }
                ColumnType::String => {
                    let encrypt_operation = make_encrypt_operation(quote!(self.#field_name.as_bytes()));
                    quote!(#encrypt_operation?)
                }
                ColumnType::OptionalBytes => {
                    let encrypt_operation = make_encrypt_operation(quote!(#field_name));
                    quote!(self.#field_name.as_ref().map(|#field_name| #encrypt_operation).transpose()?)
                }
            };

            quote!(#field_name: #field_expr)
        });

        let field_assignment = std::iter::once(id_field_assignment).chain(other_field_assignment);

        quote! {
            #[derive(serde::Serialize)]
            #visibility struct #encrypt_struct_name<#lifetime> {
                #( #field_name: #field_type, )*
            }

            impl<#lifetime> crate::traits::Encrypting<#lifetime> for #struct_name {
                type EncryptedForm = #encrypt_struct_name<#lifetime>;

                fn encrypt(&#lifetime self, cipher: &aes_gcm::Aes256Gcm) -> crate::CryptoKeystoreResult<#encrypt_struct_name> {
                    use crate::traits::EncryptData as _;
                    Ok(#encrypt_struct_name {
                        #( #field_assignment, )*
                    })
                }
            }
        }
    }
}

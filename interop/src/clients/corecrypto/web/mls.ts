// This module exists so we can use Typescript to review how our mls functions should look in `mod.rs`.
//
// While this is a Typescript file, use care to write the function bodies in pure Javascript.
// They will be copied directly into the JS environment without any transpilation!
// Even so, just having the definitions written in this file instead of as string literals
// means that TSC can help us out in case we're using the interface wrong.
//
// Note in particular that functions _must not_ use a normal parameters list. Instead they must
// internally destructure the `arguments` list. This is to conform with the webdriver `.execute` API.

import { Ciphersuite, CoreCrypto, CredentialType, MlsTransport, } from "./corecrypto.js";

declare global {
    interface Window {
        CoreCrypto: typeof CoreCrypto;
        cc: CoreCrypto;
        ciphersuite: Ciphersuite;
        credentialType: CredentialType;
        deliveryService: MlsTransport;
    }
}

export async function ccNew() {
    const { CoreCrypto, ClientId, credentialBasic, CredentialType, DatabaseKey, initWasmModule, openDatabase, ciphersuiteFromU16, MlsTransportResponse } = await import("./corecrypto.js");
    await initWasmModule("autogenerated/wasm-bindgen/");

    let [clientConfig] = arguments;
    const clientId = new ClientId(new TextEncoder().encode(clientConfig.clientId).buffer)
    const ciphersuites = clientConfig.ciphersuites.map((n) => ciphersuiteFromU16(n))

    const keyBytes = new Uint8Array(32);
    const key = new DatabaseKey(keyBytes.buffer);
    window.crypto.getRandomValues(keyBytes);
    const database = await openDatabase(clientConfig.databaseName, key);

    window.CoreCrypto = CoreCrypto;
    window.cc = new window.CoreCrypto(database);
    await window.cc.newTransaction(async (ctx) => {
        await ctx.mlsInit(clientId, ciphersuites, window.deliveryService);
        for (const ciphersuite of ciphersuites) {
            await ctx.addCredential(credentialBasic(ciphersuite, clientId));
        }
    });

    window.ciphersuite = clientConfig.ciphersuites[0];
    window.credentialType = CredentialType.Basic;

    window.deliveryService = {
        async sendCommitBundle() {
            return MlsTransportResponse.Success.new();
        },
        async sendMessage() {
            return MlsTransportResponse.Success.new();
        },
        async prepareForTransport(secret) {
            return secret.data
        }
    };
}

export async function getKeypackage() {
    const kp = await window.cc.newTransaction(async (ctx) => {
        const credentials = await ctx.getFilteredCredentials({ ciphersuite: window.ciphersuite, credentialType: window.credentialType });
        const credential = credentials[0]
        return await ctx.generateKeypackage(credential)
    });

    return new Uint8Array(kp.serialize());
}

export async function addClient() {
    const { ConversationId, Keypackage } = await import("./corecrypto.js");
    const [cId, kp] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)).buffer);
    const keyPackage = new Keypackage(Uint8Array.from(Object.values(kp)).buffer);

    if (!window.cc.conversationExists(conversationId)) {
        await window.cc.newTransaction(async (ctx) => {
            const credentials = await ctx.getFilteredCredentials({ ciphersuite: window.ciphersuite, credentialType: window.credentialType });
            const credential = credentials[0]
            await ctx.createConversation(conversationId, credential)
        });
    }
    await window.cc.newTransaction((ctx) =>
        ctx.addClientsToConversation(conversationId, [keyPackage]));
}

export async function kickClient() {
    const { ConversationId, ClientId } = await import("./corecrypto.js");
    const [cId, clId] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)).buffer);
    const clientId = new ClientId(Uint8Array.from(Object.values(clId)).buffer);
    await window.cc.newTransaction((ctx) =>
        ctx.removeClientsFromConversation(conversationId, [clientId]));
}

export async function processWelcome() {
    const { Welcome } = await import("./corecrypto.js");
    const [welcome] = arguments;
    const welcomeMessage = new Welcome(Uint8Array.from(Object.values(welcome)).buffer);

    const { id } = await window.cc.newTransaction((ctx) =>
        ctx.processWelcomeMessage(welcomeMessage));
    return new Uint8Array(id.copyBytes());
}

export async function encryptMessage() {
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, cleartext] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)).buffer);
    const message = Uint8Array.from(Object.values(cleartext)).buffer;

    return new Uint8Array(await window.cc.newTransaction((ctx) =>
        ctx.encryptMessage(conversationId, message)));
}

export async function decryptMessage() {
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, encMessage] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)).buffer);
    const encryptedMessage = Uint8Array.from(Object.values(encMessage)).buffer;

    const { message } = await window.cc.newTransaction((ctx) =>
        ctx.decryptMessage(conversationId, encryptedMessage)
    );
    return new Uint8Array(message);
}

// We can't otherwise silence the deprecation warnings generated by macros on the message definitions
#![allow(deprecated)]

use core_crypto::{MlsBufferedConversationDecryptMessage, MlsConversationDecryptMessage};

use crate::{
    ClientId, CoreCryptoError, CoreCryptoResult, WireIdentity, client_id::ClientIdMaybeArc,
    crl::NewCrlDistributionPoints,
};

/// A decrypted message and various associated metadata
#[derive(Debug, uniffi::Record)]
pub struct DecryptedMessage {
    /// Decrypted plaintext
    pub message: Option<Vec<u8>>,
    /// False if processing this message caused the client to be removed from the group, i.e. due to a Remove commit
    pub is_active: bool,
    /// Commit delay in seconds.
    ///
    /// When set, clients must delay this long before processing a commit.
    /// This reduces load on the backend, which otherwise would receive epoch change notifications from all clients simultaneously.
    pub commit_delay: Option<u64>,
    /// [ClientId] of the sender of the message being decrypted. Only present for application messages.
    pub sender_client_id: Option<ClientIdMaybeArc>,
    /// true when the decrypted message resulted in an epoch change i.e. it was a commit
    ///
    /// Deprecated: this member will be removed in the future. Prefer using the `EpochObserver` interface.
    #[deprecated = "This member will be removed in the future. Prefer using the `EpochObserver` interface."]
    pub has_epoch_changed: bool,
    /// Identity claims present in the sender credential
    pub identity: WireIdentity,
    /// Only set when the decrypted message is a commit.
    ///
    /// Contains buffered messages for next epoch which were received before the commit creating the epoch
    /// because the DS did not fan them out in order.
    pub buffered_messages: Option<Vec<BufferedDecryptedMessage>>,
    /// New CRL distribution points that appeared by the introduction of a new credential
    pub crl_new_distribution_points: NewCrlDistributionPoints,
}

impl TryFrom<MlsConversationDecryptMessage> for DecryptedMessage {
    type Error = CoreCryptoError;

    fn try_from(from: MlsConversationDecryptMessage) -> Result<Self, Self::Error> {
        let buffered_messages = from
            .buffered_messages
            .map(|bm| {
                bm.into_iter()
                    .map(TryInto::try_into)
                    .collect::<CoreCryptoResult<Vec<_>>>()
            })
            .transpose()?;

        #[expect(deprecated)]
        let msg = Self {
            message: from.app_msg,
            is_active: from.is_active,
            commit_delay: from.delay,
            sender_client_id: from.sender_client_id.map(ClientId::from_cc),
            has_epoch_changed: from.has_epoch_changed,
            identity: from.identity.try_into()?,
            buffered_messages,
            crl_new_distribution_points: from.crl_new_distribution_points.into(),
        };
        Ok(msg)
    }
}

/// to avoid recursive structs
#[derive(Debug, Clone, uniffi::Record)]
pub struct BufferedDecryptedMessage {
    /// Decrypted plaintext
    pub message: Option<Vec<u8>>,
    /// False if processing this message caused the client to be removed from the group, i.e. due to a Remove commit
    pub is_active: bool,
    /// Commit delay in seconds.
    ///
    /// When set, clients must delay this long before processing a commit.
    /// This reduces load on the backend, which otherwise would receive epoch change notifications from all clients simultaneously.
    pub commit_delay: Option<u64>,
    /// [ClientId] of the sender of the message being decrypted. Only present for application messages.
    pub sender_client_id: Option<ClientIdMaybeArc>,
    /// true when the decrypted message resulted in an epoch change i.e. it was a commit
    ///
    /// Deprecated: this member will be removed in the future. Prefer using the `EpochObserver` interface.
    #[deprecated = "This member will be removed in the future. Prefer using the `EpochObserver` interface."]
    pub has_epoch_changed: bool,
    /// Identity claims present in the sender credential
    pub identity: WireIdentity,
    /// New CRL distribution points that appeared by the introduction of a new credential
    pub crl_new_distribution_points: NewCrlDistributionPoints,
}

impl TryFrom<MlsBufferedConversationDecryptMessage> for BufferedDecryptedMessage {
    type Error = CoreCryptoError;

    fn try_from(from: MlsBufferedConversationDecryptMessage) -> Result<Self, Self::Error> {
        #[expect(deprecated)]
        let msg = Self {
            message: from.app_msg,
            is_active: from.is_active,
            commit_delay: from.delay,
            sender_client_id: from.sender_client_id.map(ClientId::from_cc),
            has_epoch_changed: from.has_epoch_changed,
            identity: from.identity.try_into()?,
            crl_new_distribution_points: from.crl_new_distribution_points.into(),
        };
        Ok(msg)
    }
}

// Wire
// Copyright (C) 2022 Wire Swiss GmbH

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.

import * as CoreCryptoFfiTypes from "./autogenerated/core_crypto_ffi";
export {
    BuildMetadata,
    WireIdentity,
    X509Identity,
} from "./autogenerated/core_crypto_ffi";

import {
    Ciphersuite,
    ClientId,
    HistorySecret,
    WireIdentity,
    ConversationId,
    openDatabase as _openDatabase,
    CoreCryptoFfi,
    proteusFingerprintPrekeybundleFfi,
    proteusLastResortPrekeyIdFfi,
} from "./autogenerated/core_crypto_ffi";

import { CoreCryptoError, ErrorType } from "./CoreCryptoError";
import {
    CredentialType,
    type MlsTransport,
    mlsTransportToFfi,
} from "./CoreCryptoMLS";

import { CoreCryptoContext } from "./CoreCryptoContext";

import { safeBigintToNumber } from "./Conversions";
import type {
    ClientIdInterface,
    DatabaseKeyInterface,
    EpochObserver,
    HistoryObserver,
} from "./autogenerated/core_crypto_ffi";

/**
 * Wrapper for the WASM-compiled version of CoreCrypto
 */
export class CoreCrypto {
    /** @hidden */
    #cc: CoreCryptoFfiTypes.CoreCryptoFfiInterface;

    /**
     * Should only be used internally
     */
    inner(): unknown {
        return this.#cc as CoreCryptoFfiTypes.CoreCryptoFfi;
    }

    /**
     * This is your entrypoint to initialize {@link CoreCrypto}!
     *
     * Calling this will generate proteus prekeys.
     * Then, those keys can be traded for a clientId.
     * Use this clientId to initialize MLS with {@link CoreCryptoContext.mlsInit}.
     * @param database - {@link Database}, initialized via {@link _openDatabase}
     */
    static async init(database: DatabaseKeyInterface): Promise<CoreCrypto> {
        const cc = await CoreCryptoError.asyncMapErr(
            CoreCryptoFfiTypes.coreCryptoNew(database)
        );
        return new this(cc);
    }

    /**
     * Instantiate a history client.
     *
     * This client exposes the full interface of `CoreCrypto`, but it should only be used to decrypt messages.
     * Other use is a logic error.
     */
    static async historyClient(
        historySecret: HistorySecret
    ): Promise<CoreCrypto> {
        const cc = await CoreCryptoError.asyncMapErr(
            CoreCryptoFfiTypes.coreCryptoHistoryClient(historySecret)
        );
        return new this(cc);
    }

    /**
     * Starts a new transaction in Core Crypto. If the callback succeeds, it will be committed,
     * otherwise, every operation performed with the context will be discarded.
     *
     * @param callback - The callback to execute within the transaction
     *
     * @returns the result of the callback will be returned from this call
     */
    async transaction<R>(
        callback: (ctx: CoreCryptoContext) => Promise<R>
    ): Promise<R> {
        let result!: R;
        let error: CoreCryptoError<ErrorType> | Error | null = null;
        try {
            await CoreCryptoError.asyncMapErr(
                this.#cc.transaction({
                    execute: async (
                        ctx: CoreCryptoFfiTypes.CoreCryptoContext
                    ) => {
                        try {
                            result = await CoreCryptoError.asyncMapErr(
                                callback(CoreCryptoContext.fromFfiContext(ctx))
                            );
                        } catch (e) {
                            // We want to catch the error before it gets wrapped by core crypto.
                            error = e as Error | CoreCryptoError<ErrorType>;
                            // This is to tell core crypto that there was an error inside the transaction.
                            throw error;
                        }
                    },
                })
            );
        } catch (e) {
            // We prefer the closure error if it's available since the transaction will just wrap and re-throw it.
            if (error === null) {
                error = e as Error | CoreCryptoError<ErrorType>;
            }
        }
        if (error !== null) {
            throw error;
        }
        return result;
    }

    /** @hidden */
    private constructor(cc: CoreCryptoFfiTypes.CoreCryptoFfiInterface) {
        this.#cc = cc;
    }

    /**
     * Waits for any transaction that is currently in progress, then closes this {@link CoreCrypto}
     * instance and deallocates all loaded resources
     *
     * **CAUTION**: This {@link CoreCrypto} instance won't be usable after a call to this method,
     * but there's no way to express this requirement in TypeScript, so you'll get errors instead!
     */
    close() {
        if (CoreCryptoFfi.instanceOf(this.#cc)) {
            this.#cc.close();
            this.#cc.uniffiDestroy();
        } else {
            throw new Error(
                "Used after Free: CoreCrypto. Did you call .close() twice?"
            );
        }
    }

    /**
     * Registers the transport callbacks for core crypto to give it access to backend endpoints for sending
     * a commit bundle or a message, respectively.
     *
     * @param transport - Any implementor of the {@link MlsTransport} interface
     * @param _ctx - unused
     */
    async provideTransport(
        transport: MlsTransport,
        _ctx: unknown = null
    ): Promise<void> {
        const transport_ffi = mlsTransportToFfi(transport);
        return await CoreCryptoError.asyncMapErr(
            this.#cc.provideTransport(transport_ffi)
        );
    }

    /**
     * See {@link CoreCryptoContext.conversationExists}.
     */
    async conversationExists(conversationId: ConversationId): Promise<boolean> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.conversationExists(conversationId)
        );
    }

    /**
     * See {@link CoreCryptoContext.conversationEpoch}.
     *
     * @returns the epoch of the conversation
     *
     * @example
     * ```ts
     *  const cc = await CoreCrypto.init({ databaseName: "test", key: "test", clientId: "test" });
     *  const encoder = new TextEncoder();
     *  console.log(await cc.conversationEpoch(encoder.encode("my super chat")))
     * ```
     */
    async conversationEpoch(conversationId: ConversationId): Promise<number> {
        const epoch = await CoreCryptoError.asyncMapErr(
            this.#cc.conversationEpoch(conversationId)
        );
        return safeBigintToNumber(epoch);
    }

    /**
     * See {@link CoreCryptoContext.conversationCiphersuite}.
     *
     * @returns the ciphersuite of the conversation
     */
    async conversationCiphersuite(
        conversationId: ConversationId
    ): Promise<Ciphersuite> {
        const cs = await CoreCryptoError.asyncMapErr(
            this.#cc.conversationCiphersuite(conversationId)
        );
        return cs;
    }

    /**
     * See {@link CoreCryptoContext.clientPublicKey}.
     *
     * @param ciphersuite - of the signature key to get
     * @param credentialType - of the public key to look for
     * @returns the client's public signature key
     */
    async clientPublicKey(
        ciphersuite: Ciphersuite,
        credentialType: CredentialType
    ): Promise<ArrayBuffer> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.clientPublicKey(ciphersuite, credentialType)
        );
    }

    /**
     * See {@link CoreCryptoContext.exportSecretKey}.
     *
     * @param conversationId - The group's ID
     * @param keyLength - the length of the key to be derived. If the value is higher than the
     * bounds of `u16` or the context hash * 255, an error will be returned
     *
     * @returns A `Uint8Array` representing the derived key
     */
    async exportSecretKey(
        conversationId: ConversationId,
        keyLength: number
    ): Promise<ArrayBuffer> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.exportSecretKey(conversationId, keyLength)
        );
    }

    /**
     * Check if history sharing is enabled, i.e., if any of the conversation members have a {@link ClientId} starting
     * with the history client id prefix.
     *
     * @param conversationId - The group's ID
     *
     * @returns Whether history sharing is enabled
     */
    async isHistorySharingEnabled(
        conversationId: ConversationId
    ): Promise<boolean> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.isHistorySharingEnabled(conversationId)
        );
    }

    /**
     * See {@link CoreCryptoContext.getExternalSender}.
     *
     * @param conversationId - The group's ID
     *
     * @returns A `Uint8Array` representing the external sender raw public key
     */
    async getExternalSender(
        conversationId: ConversationId
    ): Promise<ArrayBuffer> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.getExternalSender(conversationId)
        );
    }

    /**
     * See {@link CoreCryptoContext.getClientIds}.
     *
     * @param conversationId - The group's ID
     *
     * @returns A list of clients from the members of the group
     */
    async getClientIds(
        conversationId: ConversationId
    ): Promise<ClientIdInterface[]> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.getClientIds(conversationId)
        );
    }

    /**
     * See {@link CoreCryptoContext.randomBytes}.
     *
     * @param length - The number of bytes to be returned in the `Uint8Array`
     *
     * @returns A `Uint8Array` buffer that contains `length` cryptographically-secure random bytes
     */
    async randomBytes(length: number): Promise<ArrayBuffer> {
        return await CoreCryptoError.asyncMapErr(this.#cc.randomBytes(length));
    }

    /**
     * Allows to reseed {@link CoreCrypto}'s internal CSPRNG with a new seed.
     *
     * @param seed - **exactly 32** bytes buffer seed
     */
    async reseed(seed: ArrayBuffer): Promise<void> {
        if (seed.byteLength !== 32) {
            throw new Error(
                `The seed length needs to be exactly 32 bytes. ${seed.byteLength} bytes provided.`
            );
        }

        return await CoreCryptoError.asyncMapErr(this.#cc.reseed(seed));
    }

    /**
     * Checks if a session exists
     *
     * @param sessionId - ID of the Proteus session
     *
     * @returns whether the session exists or not
     */
    async proteusSessionExists(sessionId: string): Promise<boolean> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.proteusSessionExists(sessionId)
        );
    }

    /**
     * @returns The last resort PreKey id
     */
    static proteusLastResortPrekeyId(): number {
        return proteusLastResortPrekeyIdFfi();
    }

    /**
     * Proteus public key fingerprint
     * It's basically the public key encoded as an hex string
     *
     * @returns Hex-encoded public key string
     */
    async proteusFingerprint(): Promise<string> {
        return await CoreCryptoError.asyncMapErr(this.#cc.proteusFingerprint());
    }

    /**
     * Proteus session local fingerprint
     *
     * @param sessionId - ID of the Proteus session
     * @returns Hex-encoded public key string
     */
    async proteusFingerprintLocal(sessionId: string): Promise<string> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.proteusFingerprintLocal(sessionId)
        );
    }

    /**
     * Proteus session remote fingerprint
     *
     * @param sessionId - ID of the Proteus session
     * @returns Hex-encoded public key string
     */
    async proteusFingerprintRemote(sessionId: string): Promise<string> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.proteusFingerprintRemote(sessionId)
        );
    }

    /**
     * Hex-encoded fingerprint of the given prekey
     *
     * @param prekey - the prekey bundle to get the fingerprint from
     * @returns Hex-encoded public key string
     **/
    static proteusFingerprintPrekeybundle(prekey: ArrayBuffer): string {
        try {
            return proteusFingerprintPrekeybundleFfi(prekey);
        } catch (e) {
            throw CoreCryptoError.fromStdError(e as Error);
        }
    }

    /**
     * See {@link CoreCryptoContext.e2eiIsPKIEnvSetup}.
     * @returns whether the E2EI PKI environment is setup (i.e. Root CA, Intermediates, CRLs)
     */
    async e2eiIsPKIEnvSetup(): Promise<boolean> {
        return await this.#cc.e2eiIsPkiEnvSetup();
    }

    /**
     * See {@link CoreCryptoContext.e2eiIsEnabled}.
     *
     * @param ciphersuite of the credential to check
     * @returns true if end-to-end identity is enabled for the given ciphersuite
     */
    async e2eiIsEnabled(ciphersuite: Ciphersuite): Promise<boolean> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.e2eiIsEnabled(ciphersuite)
        );
    }

    /**
     * See {@link CoreCryptoContext.getDeviceIdentities}.
     *
     * @param conversationId - identifier of the conversation
     * @param deviceIds - identifiers of the devices
     * @returns identities or if no member has a x509 certificate, it will return an empty List
     */
    async getDeviceIdentities(
        conversationId: ConversationId,
        deviceIds: ClientId[]
    ): Promise<WireIdentity[]> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.getDeviceIdentities(conversationId, deviceIds)
        );
    }

    /**
     * See {@link CoreCryptoContext.getUserIdentities}.
     *
     * @param conversationId - identifier of the conversation
     * @param userIds - user identifiers hyphenated UUIDv4 e.g. 'bd4c7053-1c5a-4020-9559-cd7bf7961954'
     * @returns a Map with all the identities for a given users. Consumers are then recommended to reduce those identities to determine the actual status of a user.
     */
    async getUserIdentities(
        conversationId: ConversationId,
        userIds: string[]
    ): Promise<Map<string, WireIdentity[]>> {
        const map: Map<string, CoreCryptoFfiTypes.WireIdentity[]> =
            await CoreCryptoError.asyncMapErr(
                this.#cc.getUserIdentities(conversationId, userIds)
            );

        const mapFixed: Map<string, WireIdentity[]> = new Map();

        for (const [userId, identities] of map) {
            mapFixed.set(
                userId,
                identities.flatMap((identity) => {
                    return identity ? [identity] : [];
                })
            );
        }

        return mapFixed;
    }

    /**
     * Registers an epoch observer, which will then be notified every time a conversation's epoch changes.
     *
     * @param epochObserver must conform to the {@link EpochObserver} interface
     * @returns nothing
     */
    async registerEpochObserver(epochObserver: EpochObserver): Promise<void> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.registerEpochObserver(epochObserver)
        );
    }

    /**
     * Registers a history observer, which will then be notified every time a history client is created.
     *
     * @param historyObserver must conform to the {@link HistoryObserver} interface
     * @returns nothing
     */
    async registerHistoryObserver(
        historyObserver: HistoryObserver
    ): Promise<void> {
        return await CoreCryptoError.asyncMapErr(
            this.#cc.registerHistoryObserver(historyObserver)
        );
    }
}

use zeroize::ZeroizeOnDrop;

use crate::{
    CryptoKeystoreResult,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    migrations::StoredSignatureKeypair,
    traits::{
        DecryptData as _, Decryptable, Decrypting, EncryptData as _, Encrypting, Entity, EntityBase,
        EntityDatabaseMutation, PrimaryKey,
    },
};

impl EntityBase for StoredSignatureKeypair {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "mls_signature_keypairs";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        unimplemented!("Signature key pairs are not going to be used in a transaction anymore.")
    }
}

impl PrimaryKey for StoredSignatureKeypair {
    type PrimaryKey = Vec<u8>;

    fn primary_key(&self) -> Self::PrimaryKey {
        self.pk.clone()
    }
}

#[async_trait::async_trait(?Send)]
impl Entity for StoredSignatureKeypair {
    async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CryptoKeystoreResult<Option<Self>> {
        conn.storage().new_get(key).await
    }

    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        conn.storage().new_count::<Self>().await
    }

    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        conn.storage().new_get_all::<Self>().await
    }
}

#[async_trait::async_trait(?Send)]
impl<'a> EntityDatabaseMutation<'a> for StoredSignatureKeypair {
    type Transaction = TransactionWrapper<'a>;

    async fn save(&'a self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        tx.new_save(self).await
    }

    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        tx.new_count::<Self>().await
    }

    async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> CryptoKeystoreResult<bool> {
        tx.new_delete::<Self>(id).await
    }
}

#[derive(ZeroizeOnDrop, serde::Serialize, serde::Deserialize)]
pub(crate) struct EncryptedStoredSignatureKeypair {
    pub pk: Vec<u8>,
    pub credential_id: Vec<u8>,
    pub signature_scheme: u16,
    pub keypair: Vec<u8>,
}

impl Decrypting<'static> for EncryptedStoredSignatureKeypair {
    type DecryptedForm = StoredSignatureKeypair;

    fn decrypt(mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::DecryptedForm> {
        let pk = std::mem::take(&mut self.pk);
        let credential_id = std::mem::take(&mut self.credential_id);
        let signature_scheme = self.signature_scheme;

        let keypair = StoredSignatureKeypair::decrypt_data(cipher, &pk, &self.keypair)?;

        Ok(StoredSignatureKeypair {
            pk,
            credential_id,
            signature_scheme,
            keypair,
        })
    }
}

impl Decryptable<'static> for StoredSignatureKeypair {
    type DecryptableFrom = EncryptedStoredSignatureKeypair;
}

impl<'a> Encrypting<'a> for StoredSignatureKeypair {
    type EncryptedForm = EncryptedStoredSignatureKeypair;

    fn encrypt(&'a self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::EncryptedForm> {
        let pk = self.pk.clone();
        let credential_id = self.credential_id.clone();
        let signature_scheme = self.signature_scheme;

        let keypair = self.encrypt_data(cipher, &self.keypair)?;

        Ok(EncryptedStoredSignatureKeypair {
            pk,
            credential_id,
            signature_scheme,
            keypair,
        })
    }
}

use std::{borrow::Cow, sync::Arc};

use async_lock::{RwLockReadGuardArc, RwLockUpgradableReadGuard, RwLockUpgradableReadGuardArc, SemaphoreGuardArc};

use crate::connection::KeystoreDatabaseConnection;
use crate::transaction::cache_record::CacheRecord;
use crate::transaction::transaction_store::{CachedEntity, TransactionStore};
use crate::{
    CryptoKeystoreError, CryptoKeystoreResult,
    connection::Database,
    entities::{MlsPendingMessage, PersistedMlsGroup},
    traits::{BorrowPrimaryKey, EntityDatabaseMutation, EntityDeleteBorrowed, KeyType, SearchableEntity},
};

pub(crate) mod cache_record;
pub(crate) mod dynamic_dispatch;
pub(crate) mod transaction_store;

/// This represents a transaction, where all operations will be done in memory and committed at the
/// end
#[derive(Debug, Clone)]
pub(crate) struct KeystoreTransaction {
    transaction_store: Arc<TransactionStore>,
    _semaphore_guard: Arc<SemaphoreGuardArc>,
}

impl KeystoreTransaction {
    /// Instantiate a new transaction.
    ///
    /// Requires a semaphore guard to ensure that only one exists at a time.
    pub(crate) async fn new(semaphore_guard: SemaphoreGuardArc) -> CryptoKeystoreResult<Self> {
        Ok(Self {
            transaction_store: Arc::new(TransactionStore::default()),
            _semaphore_guard: Arc::new(semaphore_guard),
        })
    }

    /// Save an entity into this transaction.
    ///
    /// This is a multi-step process:
    ///
    /// - Adjust the entity by calling its [`pre_save()`][Entity::pre_save] method.
    /// - Store the entity in an internal map.
    ///   - Remove the entity from the set of deleted entities, if it was there.
    /// - On [`Self::commit`], actually persist the entity into the supplied database.
    pub(crate) async fn save<'a, E>(&self, mut entity: E) -> CryptoKeystoreResult<E::AutoGeneratedFields>
    where
        E: CachedEntity<ConnectionType = KeystoreDatabaseConnection> + EntityDatabaseMutation<'a> + Send + Sync,
    {
        let auto_generated_fields = entity.pre_save().await?;

        self.delete_or_save(entity.primary_key().bytes(), Some(entity)).await?;

        Ok(auto_generated_fields)
    }

    async fn remove_by_entity_id<'a, E>(&self, id: Cow<'_, [u8]>) -> CryptoKeystoreResult<()>
    where
        E: CachedEntity + EntityDatabaseMutation<'a>,
    {
        // rm this entity from the set of added/modified items
        // it might never touch the real db at all
        // start by adding the entity
        self.delete_or_save::<E>(id, None).await
    }

    async fn delete_or_save<'a, E>(&self, id: Cow<'_, [u8]>, entity: Option<E>) -> CryptoKeystoreResult<()>
    where
        E: CachedEntity + EntityDatabaseMutation<'a>,
    {
        let cache = self.transaction_store.cache::<E>().await;

        if let Some(record) = cache.get(&id.to_vec()) {
            let mut guard = record.write().await;
            *guard = entity;
        } else {
            let entry = CacheRecord::<E>::new(entity, true);
            let mut cache = RwLockUpgradableReadGuardArc::upgrade(cache).await;
            cache.insert(id.to_vec(), entry);
        }

        Ok(())
    }

    /// Remove an entity by its primary key.
    ///
    /// Where the primary key has a distinct borrowed form, consider [`Self::remove_borrowed`].
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove<'a, E>(&self, id: &E::PrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: CachedEntity + EntityDatabaseMutation<'a>,
    {
        self.remove_by_entity_id::<E>(id.bytes()).await
    }

    /// Remove an entity by the borrowed form of its primary key.
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove_borrowed<'a, E>(&self, id: &E::BorrowedPrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: CachedEntity + EntityDeleteBorrowed<'a> + BorrowPrimaryKey,
    {
        self.remove_by_entity_id::<E>(id.to_owned().bytes()).await
    }

    pub(crate) async fn child_groups(
        &self,
        entity: PersistedMlsGroup,
        persisted_records: impl IntoIterator<Item = PersistedMlsGroup>,
    ) -> Vec<RwLockReadGuardArc<Option<PersistedMlsGroup>>> {
        self.extend_cache::<PersistedMlsGroup>(persisted_records).await;

        self.find_all_in_cache::<PersistedMlsGroup>()
            .await
            .into_iter()
            .filter(|maybe_child| {
                maybe_child
                    .as_ref()
                    .and_then(|child| child.parent_id.as_deref())
                    .map(|pid| pid == entity.borrow_primary_key().bytes().as_ref())
                    .unwrap_or_default()
            })
            .collect()
    }

    pub(crate) async fn remove_pending_messages_by_conversation_id(&self, conversation_id: impl AsRef<[u8]> + Send) {
        let conversation_id = conversation_id.as_ref();
        let pending_messages_table = self.transaction_store.cache::<MlsPendingMessage>().await;
        for (_, record) in pending_messages_table.iter() {
            let pending_message_guard = record.upgradable_read().await;

            if let Some(pending_message) = pending_message_guard.as_ref()
                && pending_message.foreign_id == conversation_id
            {
                // upgrade lock and manually set record dirty
                let mut pending_message = RwLockUpgradableReadGuard::upgrade(pending_message_guard).await;
                *pending_message = None;
                record.set_dirty();
            }
        }
    }

    pub(crate) async fn find_pending_messages_by_conversation_id(
        &self,
        conversation_id: &[u8],
        persisted_records: impl IntoIterator<Item = MlsPendingMessage>,
    ) -> Vec<RwLockReadGuardArc<Option<MlsPendingMessage>>> {
        self.extend_cache::<MlsPendingMessage>(persisted_records).await;

        self.find_all_in_cache::<MlsPendingMessage>()
            .await
            .into_iter()
            .filter(|pending_message| {
                pending_message
                    .as_ref()
                    .map(|id| id.foreign_id == conversation_id)
                    .unwrap_or_default()
            })
            .collect()
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get<'a, E>(&'a self, id: &E::PrimaryKey) -> Option<RwLockReadGuardArc<Option<E>>>
    where
        E: CachedEntity + Send + Sync,
    {
        let table = self.transaction_store.cache::<E>().await;
        let id = id.bytes();

        if let Some(entity) = table.get(id.as_ref()) {
            Some(entity.read_arc().await)
        } else {
            None
        }
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get_borrowed<E>(&self, id: &E::BorrowedPrimaryKey) -> Option<RwLockReadGuardArc<Option<E>>>
    where
        E: CachedEntity + BorrowPrimaryKey + Send + Sync,
        <E as BorrowPrimaryKey>::BorrowedPrimaryKey: KeyType,
    {
        let table = self.transaction_store.cache::<E>().await;
        let id = id.bytes();

        if let Some(entity) = table.get(id.as_ref()) {
            Some(entity.read_arc().await)
        } else {
            None
        }
    }

    async fn find_all_in_cache<E>(&self) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: CachedEntity + Send + Sync,
    {
        let table = self.transaction_store.cache::<E>().await;
        let mut records = Vec::with_capacity(table.values().len());
        for record in table.values() {
            records.push(record.read_arc().await);
        }
        records
    }

    async fn search_in_cache<E, SearchKey>(&self, search_key: &SearchKey) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: CachedEntity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        self.find_all_in_cache::<E>()
            .await
            .into_iter()
            .map(|record| record)
            .filter(|record| record.as_ref().is_some_and(|e| e.matches(search_key)))
            .collect()
    }

    pub(crate) async fn find_all<E>(&self, persisted_records: Vec<E>) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Clone + CachedEntity + Send + Sync,
    {
        self.extend_cache(persisted_records).await;
        self.find_all_in_cache::<E>().await
    }

    pub(crate) async fn search<E, SearchKey>(
        &self,
        persisted_records: Vec<E>,
        search_key: &SearchKey,
    ) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Clone + CachedEntity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        self.extend_cache(persisted_records);
        self.search_in_cache(search_key).await
    }

    /// Put each of the given items into the cache if the cache doesn't contain its id yet.
    async fn extend_cache<'a, E>(&self, records: impl IntoIterator<Item = E>)
    where
        E: CachedEntity,
    {
        let table = self.transaction_store.cache::<E>().await;
        let mut table = RwLockUpgradableReadGuardArc::upgrade(table).await;

        for record in records {
            let record_id = record.primary_key().bytes().to_vec();
            if !table.contains_key(&record_id) {
                table.insert(record_id, CacheRecord::<E>::new(Some(record), false));
            }
        }
    }

    /// Persists all the operations in the database. It will effectively open a transaction
    /// internally, perform all the buffered operations and commit.
    pub(crate) async fn commit(&self, db: &Database) -> Result<(), CryptoKeystoreError> {
        let conn = db.conn().await?;
        let mut conn = conn.conn().await;

        // open a database transaction
        #[cfg(target_family = "wasm")]
        let tx = conn
            .new_transaction(transaction_store.dirty_caches_names().await)
            .await?;
        #[cfg(not(target_family = "wasm"))]
        let tx = conn.transaction()?.into();

        self.transaction_store.flush(&tx);
        // and commit everything
        tx.commit_tx().await?;

        Ok(())
    }
}

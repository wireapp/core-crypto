extern crate proc_macro;

use darling::FromDeriveInput as _;
use proc_macro::TokenStream;
use proc_macro2::Ident;
use quote::quote;
use syn::{
    Attribute, Block, DeriveInput, FnArg, ItemFn, ReturnType, Visibility, parse_macro_input, punctuated::Punctuated,
    token::Comma,
};

mod debug;
mod durable;
mod entity_derive;
mod idempotent;

/// Implements the `Entity` trait and related traits for the given struct.
///
/// Intended to be used only within `core-crypto-keystore`.
///
/// All fields in an entity using this derive macro must have one of three types:
///
/// - `Vec<u8>`
/// - `String`
/// - `Option<Vec<u8>>`
///
/// There is one exception: the identity field can only be a `Vec<u8>` or `String`; the optional
/// variant is forbidden in that context.
///
/// This is intentionally restrictive. If your entity has other field types, implement these traits manually.
///
/// ## Attributes
///
/// Attributes modify the code generated by this proc macro by adding annotations to the whole struct
/// or to distinct fields. All attributes accepted by this proc macro are keyed with `#[entity]`.
/// The attribute itself appears in the following parenthesis.
///
/// It is acceptable to combine multiple entity attributes together, simply by combining them
/// within the parenthesis, separated by commas: `#[entity(id, column_name="column")]`, for example.
///
/// ### `#[entity(collection_name = "my_collection")]`
///
/// This is an **outer attribute** which modifies the entire item. Its parameters:
///
/// - `collection_name`: Optional. When set, this specifies the collection name which will be used. Otherwise, one will
///   be generated by transforming the item name to snake case and adding an `s`.
///
/// ### `#[entity(id)]`
///
/// This is a **field attribute** which can be applied to at most 1 field in the item.
///
/// The field to which this attribute is applied must have type `Vec<u8>` or `String`.
/// Otherwise, you must implement all relevant entity traits manually instead of relying on this macro.
///
/// If this attribute does not appear, the macro will search for a field whose name is `id` and assume
/// that is an implicit id.
///
/// This attribute does not accept a value.
///
/// ### `#[entity(column = "my_column")]`
///
/// This is a **field attribute** which can be applied to any number of fields in the struct.
///
/// The `column` value will be used as the SQL column name for this field. If this is unset, the field's name
/// will be used as the sql column name.
///
/// ### `#[entity(unencrypted_wasm)]`
///
/// This is a **field attribute** which can be applied to any number of fields in the struct.
///
/// When set, this field is excluded from item-level encryption and is stored in plaintext in wasm.
/// (Item-level encryption is never applied for non-wasm implementations anyway.)
///
/// ## Trait Implementations
///
/// ### Implements
///
/// - `EntityBase`
/// - `Entity`
/// - `BorrowPrimaryKey`
/// - `EntityDatabaseMutation`
/// - `EntityDeleteBorrowed`
/// - `Encrypting` (+ relevant associated struct)
/// - `Decrypting` (+ relevant associated struct)
/// - `Decryptable`
///
/// ### `EntityBase`
///
/// This trait effectively stores only the collection name, and generates the transaction entity based on the item name.
///
/// No fields are autogenerated. If any fields should be autogenerated, you must implement all relevant traits manually.
///
/// ### `Entity`
///
/// The primary key for all derived entities is `Vec<u8>`. For a more complicated primary key, you need to implement
/// all these traits manually.
///
/// Implementations of non-wasm methods defer to the helper functions defined in `entities::platform::generic`.
///
/// ### `BorrowPrimaryKey`
///
/// The borrowed form of the primary key for all derived entities is `&[u8]`. For a more complicated borrowed primary
/// key, you need to implement all these traits manually.
///
/// Implementation of `get_borrowed` defers to the helper function defined in `entities::platform::generic`.
///
/// ### `EntityDatabaseMutation`
///
/// The derived `save` method (non-wasm) generates sql like:
///
/// ```sql
/// INSERT OR REPLACE INTO entities (id, foo, bar) VALUES (?, ?, ?)
/// ```
///
/// The wasm implementation delegates to the transaction's `save` method, which serializes via serde.
///
/// ### Item-level encryption (i.e. `Encrypting`, `Decrypting`)
///
/// All fields except the id field are encrypted. If you need more unencrypted fields, implement this trait family
/// yourself.
///
/// This macro generates an encryption helper associated struct. If this item is `Foo`, the associated struct is
/// `FooEncrypt`. `FooEncrypt` implements `serde::Serialize`. Expected usage:
///
/// ```rust,ignore
/// let encrypted = serde_json::to_string(&foo.encrypt(cipher)?)?;
/// ```
///
/// This macro generates a decryption helper associated struct. If this item is `Foo`, the associated struct is
/// `FooDecrypt`. `FooDecrypt` implements `serde::Deserialize` and `Decrypting`, with `FooDecrypt::DecryptedForm:
/// Foo`. `Foo` implements `Decryptable`, with `Decryptable::DecryptableFrom: FooDecrypt`. Expected usage:
///
/// ```rust,ignore
/// let decrypted = serde_json::from_str::<Foo::DecryptableFrom>(&encrypted)?.decrypt(cipher)?;
/// ```
#[proc_macro_derive(Entity, attributes(entity))]
pub fn derive_entity(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    match entity_derive::Entity::from_derive_input(&input) {
        Ok(entity) => quote! { #entity },
        Err(err) => err.write_errors(),
    }
    .into()
}

/// Will drop current MLS group in memory and replace it with the one in the keystore.
/// This simulates an application crash. Once restarted, everything has to be loaded from the
/// keystore, memory is lost.
///
/// Requires the `MlsConversation` method to have a parameter exactly like `backend: &MlsCryptoProvider`
///
/// This helps spotting:
/// * when one has forgotten to call `persist_group_when_changed`
/// * if persisted fields are sufficient to pursue normally after a crash
///
/// **IF** you mark a method `#[durable]`, remove its call to
/// `persist_group_when_changed` and tests still pass, you either:
/// * have unit tests not covering the method enough
/// * do not require this method to be durable
#[proc_macro_attribute]
pub fn durable(_args: TokenStream, item: TokenStream) -> TokenStream {
    durable::durable(item)
}

/// !!! Not literally idempotent !!!
///
/// Marker for methods on 'core_crypto::Client' which leave the number of entities in the keystore even.
/// They can create/destroy some but always compensate.
/// So they are not idempotent, they cannot be safely replayed and they might leave the keystore in
/// a different state.
#[proc_macro_attribute]
pub fn idempotent(_args: TokenStream, item: TokenStream) -> TokenStream {
    idempotent::idempotent(item)
}

/// Neologism to mean the opposite of idempotent. Methods of 'core_crypto::Client' marked with this have to
/// insert/delete an entity in the keystore and change the number of entities persisted.
#[proc_macro_attribute]
pub fn dispotent(_args: TokenStream, item: TokenStream) -> TokenStream {
    idempotent::dispotent(item)
}

pub(crate) fn doc_attributes(ast: &ItemFn) -> Vec<Attribute> {
    ast.attrs
        .iter()
        .filter(|attr| attr.path().is_ident("doc"))
        .cloned()
        .collect::<Vec<syn::Attribute>>()
}

pub(crate) fn compile_error(mut item: TokenStream, err: syn::Error) -> TokenStream {
    let compile_err = TokenStream::from(err.to_compile_error());
    item.extend(compile_err);
    item
}

#[allow(clippy::type_complexity)]
pub(crate) fn items(
    ast: &ItemFn,
) -> (
    &ReturnType,
    &Ident,
    &Punctuated<FnArg, Comma>,
    &Box<Block>,
    &Vec<Attribute>,
    &Visibility,
) {
    let ret = &ast.sig.output;
    let name = &ast.sig.ident;
    let inputs = &ast.sig.inputs;
    let body = &ast.block;
    let attrs = &ast.attrs;
    let vis = &ast.vis;
    (ret, name, inputs, body, attrs, vis)
}

/// Implements the `Debug` trait for the given struct changing the formatting of `Vec<u8>` fields.
/// Structs deriving this custom `Debug` debug `Vec<u8>` or `Option<Vec<u8>>` as a hex string.
/// Fields can be marked as sensitive to obfuscate them when logged. This needs the field type to implement `Obfuscate`.
#[proc_macro_derive(Debug, attributes(sensitive))]
pub fn derive_debug_bytes(input: TokenStream) -> TokenStream {
    debug::derive_debug(input)
}

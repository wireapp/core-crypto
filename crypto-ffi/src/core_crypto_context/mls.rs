use std::{sync::Arc, time::Duration};

use core_crypto::{
    Ciphersuite as CryptoCiphersuite, ClientIdentifier, CredentialFindFilters, MlsConversationConfiguration,
    RecursiveError, VerifiableGroupInfo, mls::conversation::Conversation as _,
    transaction_context::Error as TransactionError,
};
use tls_codec::Deserialize as _;

use crate::{
    Ciphersuite, ClientId, ConversationId, CoreCryptoContext, CoreCryptoResult, Credential, CredentialRef,
    CredentialType, DecryptedMessage, Keypackage, KeypackageRef, MlsTransport, WelcomeBundle,
    bytes_wrapper::bytes_wrapper, core_crypto::mls_transport::callback_shim, crl::NewCrlDistributionPoints,
};

bytes_wrapper!(
    /// A secret key derived from the group secret.
    ///
    /// This is intended to be used for AVS.
    SecretKey
);
bytes_wrapper!(
    /// The raw public key of an external sender.
    ///
    /// This can be used to initialize a subconversation.
    #[derive(Debug, Clone)]
    ExternalSenderKey
);
bytes_wrapper!(
    /// MLS Group Information
    ///
    /// This is used when joining by external commit.
    /// It can be found within the `GroupInfoBundle` within a `CommitBundle`.
    #[derive(Debug, Clone)]
    GroupInfo
);
bytes_wrapper!(
    /// A TLS-serialized Welcome message.
    ///
    /// This structure is defined in RFC 9420:
    /// <https://www.rfc-editor.org/rfc/rfc9420.html#joining-via-welcome-message>.
    #[derive(Debug, Clone)]
    Welcome
);

#[uniffi::export]
impl CoreCryptoContext {
    /// See [core_crypto::transaction_context::TransactionContext::mls_init]
    pub async fn mls_init(
        &self,
        client_id: &Arc<ClientId>,
        ciphersuites: Vec<Ciphersuite>,
        transport: Arc<dyn MlsTransport>,
    ) -> CoreCryptoResult<()> {
        let transport = callback_shim(transport);
        self.inner
            .mls_init(
                ClientIdentifier::Basic(client_id.as_ref().as_ref().to_owned()),
                &ciphersuites
                    .into_iter()
                    .map(CryptoCiphersuite::from)
                    .collect::<Vec<_>>(),
                transport,
            )
            .await?;
        Ok(())
    }

    /// See [core_crypto::mls::conversation::Conversation::epoch]
    pub async fn conversation_epoch(&self, conversation_id: &ConversationId) -> CoreCryptoResult<u64> {
        let conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        Ok(conversation.epoch().await)
    }

    /// See [core_crypto::mls::conversation::Conversation::ciphersuite]
    pub async fn conversation_ciphersuite(&self, conversation_id: &ConversationId) -> CoreCryptoResult<Ciphersuite> {
        let cs = self
            .inner
            .conversation(conversation_id.as_ref())
            .await?
            .ciphersuite()
            .await;
        Ok(Ciphersuite::from(cs))
    }

    /// Get the credential ref for the given conversation.
    pub async fn conversation_credential(&self, conversation_id: &ConversationId) -> CoreCryptoResult<CredentialRef> {
        self.inner
            .conversation(conversation_id.as_ref())
            .await?
            .credential_ref()
            .await
            .map(Into::into)
            .map_err(Into::into)
    }

    /// Set the credential ref for the given conversation.
    pub async fn set_conversation_credential(
        &self,
        conversation_id: &ConversationId,
        credential_ref: Arc<CredentialRef>,
    ) -> CoreCryptoResult<()> {
        self.inner
            .conversation(conversation_id.as_ref())
            .await?
            .set_credential_by_ref(&credential_ref.0)
            .await
            .map_err(Into::into)
    }

    /// See [core_crypto::Session::conversation_exists]
    pub async fn conversation_exists(&self, conversation_id: &ConversationId) -> CoreCryptoResult<bool> {
        self.inner
            .conversation_exists(conversation_id.as_ref())
            .await
            .map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::Conversation::get_client_ids]
    pub async fn get_client_ids(&self, conversation_id: &ConversationId) -> CoreCryptoResult<Vec<Arc<ClientId>>> {
        let conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        let client_ids = conversation
            .get_client_ids()
            .await
            .into_iter()
            .map(Into::into)
            .map(Arc::new)
            .collect();
        Ok(client_ids)
    }

    /// See [core_crypto::mls::conversation::Conversation::export_secret_key]
    pub async fn export_secret_key(
        &self,
        conversation_id: &ConversationId,
        key_length: u32,
    ) -> CoreCryptoResult<SecretKey> {
        let conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation
            .export_secret_key(key_length as usize)
            .await
            .map(Into::into)
            .map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::Conversation::get_external_sender]
    pub async fn get_external_sender(&self, conversation_id: &ConversationId) -> CoreCryptoResult<ExternalSenderKey> {
        let conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation
            .get_external_sender()
            .await
            .map(Into::into)
            .map_err(Into::into)
    }

    /// See [core_crypto::transaction_context::TransactionContext::new_conversation]
    pub async fn create_conversation(
        &self,
        conversation_id: &ConversationId,
        credential_ref: &CredentialRef,
        external_sender: Option<Arc<ExternalSenderKey>>,
    ) -> CoreCryptoResult<()> {
        let mut lower_cfg = MlsConversationConfiguration {
            ciphersuite: credential_ref.ciphersuite().into(),
            ..Default::default()
        };

        lower_cfg
            .set_raw_external_senders(
                &self.inner.mls_provider().await?,
                external_sender
                    .into_iter()
                    .map(|external_sender| external_sender.copy_bytes()),
            )
            .await?;

        self.inner
            .new_conversation(conversation_id.as_ref(), &credential_ref.0, lower_cfg)
            .await?;
        Ok(())
    }

    /// See [core_crypto::transaction_context::TransactionContext::process_raw_welcome_message]
    pub async fn process_welcome_message(&self, welcome_message: Arc<Welcome>) -> CoreCryptoResult<WelcomeBundle> {
        let result = self
            .inner
            .process_raw_welcome_message(welcome_message.as_slice())
            .await?
            .into();
        Ok(result)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::add_members]
    pub async fn add_clients_to_conversation(
        &self,
        conversation_id: &ConversationId,
        key_packages: Vec<Arc<Keypackage>>,
    ) -> CoreCryptoResult<NewCrlDistributionPoints> {
        let keypackages = key_packages
            .into_iter()
            .map(std::sync::Arc::unwrap_or_clone)
            .map(Into::into)
            .collect();

        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        let distribution_points = conversation.add_members(keypackages).await?.into();
        Ok(distribution_points)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::remove_members]
    pub async fn remove_clients_from_conversation(
        &self,
        conversation_id: &ConversationId,
        clients: Vec<Arc<ClientId>>,
    ) -> CoreCryptoResult<()> {
        let clients: Vec<&core_crypto::ClientIdRef> = clients.iter().map(|c| c.as_ref().as_ref()).collect();
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.remove_members(&clients).await.map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::mark_as_child_of]
    pub async fn mark_conversation_as_child_of(
        &self,
        child_id: &ConversationId,
        parent_id: &ConversationId,
    ) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(child_id.as_ref()).await?;
        conversation
            .mark_as_child_of(parent_id.as_ref())
            .await
            .map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::update_key_material]
    pub async fn update_keying_material(&self, conversation_id: &ConversationId) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.update_key_material().await.map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::commit_pending_proposals]
    pub async fn commit_pending_proposals(&self, conversation_id: &ConversationId) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.commit_pending_proposals().await.map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::wipe]
    pub async fn wipe_conversation(&self, conversation_id: &ConversationId) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.wipe().await.map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::decrypt_message]
    pub async fn decrypt_message(
        &self,
        conversation_id: &ConversationId,
        payload: Vec<u8>,
    ) -> CoreCryptoResult<DecryptedMessage> {
        let conversation_result = self.inner.conversation(conversation_id.as_ref()).await;
        let decrypted_message = match conversation_result {
            Err(TransactionError::PendingConversation(mut pending)) => {
                pending.try_process_own_join_commit(&payload).await?
            }
            Ok(mut conversation) => conversation.decrypt_message(&payload).await?,
            Err(e) => Err(e)?,
        };

        Ok(decrypted_message.into())
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::encrypt_message]
    pub async fn encrypt_message(
        &self,
        conversation_id: &ConversationId,
        message: Vec<u8>,
    ) -> CoreCryptoResult<Vec<u8>> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.encrypt_message(message).await.map_err(Into::into)
    }

    /// See [core_crypto::transaction_context::TransactionContext::join_by_external_commit]
    pub async fn join_by_external_commit(
        &self,
        group_info: Arc<GroupInfo>,
        credential_ref: Arc<CredentialRef>,
    ) -> CoreCryptoResult<WelcomeBundle> {
        let group_info = VerifiableGroupInfo::tls_deserialize(&mut group_info.as_slice())
            .map_err(core_crypto::mls::conversation::Error::tls_deserialize(
                "verifiable group info",
            ))
            .map_err(RecursiveError::mls_conversation("joining by external commmit"))?;
        let welcome_bundle = self
            .inner
            .join_by_external_commit(group_info, &credential_ref.0)
            .await?;
        Ok(welcome_bundle.into())
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::enable_history_sharing]
    pub async fn enable_history_sharing(&self, conversation_id: &ConversationId) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.enable_history_sharing().await.map_err(Into::into)
    }

    /// See [core_crypto::mls::conversation::ConversationGuard::disable_history_sharing]
    pub async fn disable_history_sharing(&self, conversation_id: &ConversationId) -> CoreCryptoResult<()> {
        let mut conversation = self.inner.conversation(conversation_id.as_ref()).await?;
        conversation.disable_history_sharing().await.map_err(Into::into)
    }

    /// Add a [`Credential`][crate::Credential] to this client.
    ///
    /// Note that while an arbitrary number of credentials can be generated,
    /// those which are added to a CC instance must be distinct in credential type,
    /// signature scheme, and the timestamp of creation. This timestamp has only
    /// 1 second of resolution, limiting the number of credentials which
    /// can be added. This is a known limitation and will be relaxed in the future.
    pub async fn add_credential(&self, credential: Arc<Credential>) -> CoreCryptoResult<CredentialRef> {
        let credential = std::sync::Arc::unwrap_or_clone(credential);
        let credential_ref = self.inner.add_credential(credential.0).await?;
        Ok(credential_ref.into())
    }

    /// Remove a [`Credential`][crate::Credential] from this client.
    pub async fn remove_credential(&self, credential_ref: &Arc<CredentialRef>) -> CoreCryptoResult<()> {
        let credential_ref = credential_ref.as_ref();
        self.inner.remove_credential(&credential_ref.0).await?;
        Ok(())
    }

    /// Get all credentials from this client.
    pub async fn get_credentials(&self) -> CoreCryptoResult<Vec<Arc<CredentialRef>>> {
        self.inner
            .get_credentials()
            .await
            .map(|credentials| credentials.into_iter().map(CredentialRef::from).map(Arc::new).collect())
            .map_err(Into::into)
    }

    /// Get all credentials from this client which match the provided parameters.
    ///
    /// Parameters which are unset or `None` match anything. Those with a particular value find only credentials
    /// matching that value.
    pub async fn find_credentials(
        &self,
        client_id: Option<Arc<ClientId>>,
        public_key: Option<Vec<u8>>,
        ciphersuite: Option<Ciphersuite>,
        credential_type: Option<CredentialType>,
        earliest_validity: Option<u64>,
    ) -> CoreCryptoResult<Vec<Arc<CredentialRef>>> {
        let client_id = client_id.as_ref().map(|c| c.as_ref().as_ref());

        let ciphersuite = ciphersuite.map(CryptoCiphersuite::from);

        let credential_type = credential_type.map(core_crypto::CredentialType::from);

        let find_filters = CredentialFindFilters {
            client_id,
            public_key: public_key.as_deref(),
            ciphersuite,
            credential_type,
            earliest_validity,
        };

        self.inner
            .find_credentials(find_filters)
            .await
            .map(|credentials| credentials.into_iter().map(CredentialRef::from).map(Arc::new).collect())
            .map_err(Into::into)
    }

    /// Generate a `KeyPackage` from the referenced credential.
    ///
    /// Makes no attempt to look up or prune existing keypackges.
    ///
    /// If `lifetime` is set, the keypackages will expire that span into the future.
    /// If it is unset, a default lifetime of approximately 3 months is used.
    #[uniffi::method(default(lifetime = None))]
    pub async fn generate_keypackage(
        &self,
        credential_ref: &Arc<CredentialRef>,
        lifetime: Option<Duration>,
    ) -> CoreCryptoResult<Arc<Keypackage>> {
        let credential_ref = &credential_ref.0;
        self.inner
            .generate_keypackage(credential_ref, lifetime)
            .await
            .map(Keypackage::coerce_arc)
            .map_err(Into::into)
    }

    /// Get a reference to each `KeyPackage` in the database.
    pub async fn get_keypackages(&self) -> CoreCryptoResult<Vec<Arc<KeypackageRef>>> {
        self.inner
            .get_keypackage_refs()
            .await
            .map(|kp_refs| kp_refs.into_iter().map(KeypackageRef::coerce_arc).collect())
            .map_err(Into::into)
    }

    /// Remove a `KeyPackage` from the database.
    pub async fn remove_keypackage(&self, kp_ref: &Arc<KeypackageRef>) -> CoreCryptoResult<()> {
        self.inner.remove_keypackage(kp_ref.as_cc()).await.map_err(Into::into)
    }

    /// Remove all `KeyPackage`s associated with this credential ref.
    pub async fn remove_keypackages_for(&self, credential_ref: &Arc<CredentialRef>) -> CoreCryptoResult<()> {
        self.inner
            .remove_keypackages_for(&credential_ref.0)
            .await
            .map_err(Into::into)
    }
}

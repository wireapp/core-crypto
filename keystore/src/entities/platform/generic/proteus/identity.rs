use rusqlite::OptionalExtension;

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult, Entity, EntityBase, EntityTransactionExt, UniqueEntity,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    entities::ProteusIdentity,
};

impl EntityBase for ProteusIdentity {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = ();
    const COLLECTION_NAME: &'static str = "proteus_identities";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::ProteusIdentity(self)
    }
}

impl UniqueEntity for ProteusIdentity {
    const KEY: () = ();
}

#[async_trait::async_trait]
impl Entity for ProteusIdentity {
    /// Each distinct [`PrimaryKey`] uniquely identifies either 0 or 1 instance.
    ///
    /// This constraint should be enforced at the DB level.
    type PrimaryKey = ();

    /// Get this entity's primary key.
    fn primary_key(&self) -> Self::PrimaryKey {
        ()
    }

    /// Get an entity by its primary key.
    ///
    /// The type signature here is somewhat complicated, but it breaks down simply: if our primary key is something
    /// like `Vec<u8>`, we want to be able to use this method even if what we have on hand is `&[u8]`.
    ///
    /// Actually ignoring the key here is unusual, but acceptable for a unique entity.
    async fn get(conn: &mut Self::ConnectionType, _key: &()) -> CryptoKeystoreResult<Option<Self>> {
        let conn = conn.conn().await;
        // this gets the oldest identity, and is retained behavior from a previous implementation:
        // it used to save additional bonus identities without error
        let mut statement = conn.prepare_cached("SELECT pk, sk FROM proteus_identities ORDER BY rowid ASC LIMIT 1")?;
        let Some(identity) = statement
            .query_row([], |row| {
                let identity = ProteusIdentity {
                    pk: row.get("pk")?,
                    sk: row.get("sk")?,
                };
                Ok(identity)
            })
            .optional()?
        else {
            return Ok(None);
        };

        if identity.pk.len() != Self::PK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::PK_KEY_SIZE,
                actual: identity.pk.len(),
                key: "pk",
            });
        }
        if identity.sk.len() != Self::SK_KEY_SIZE {
            return Err(CryptoKeystoreError::InvalidKeySize {
                expected: Self::SK_KEY_SIZE,
                actual: identity.sk.len(),
                key: "sk",
            });
        }

        Ok(Some(identity))
    }

    /// Count the number of entities of this type in the database.
    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        let conn = conn.conn().await;
        let mut statement = conn.prepare_cached("SELECT COUNT(*) FROM proteus_identities")?;
        let count = statement.query_one([], |row| row.get(0))?;
        // This should always be less or equal 1
        debug_assert!(count <= 1);
        Ok(count)
    }

    /// Retrieve all entities of this type from the database.
    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        Self::get(conn, &())
            .await
            .map(|optional| optional.into_iter().collect())
    }
}

#[async_trait::async_trait]
impl<'a> EntityTransactionExt<'a> for ProteusIdentity {
    type Transaction = TransactionWrapper<'a>;

    /// Use the transaction's interface to count the number of entities of this type in the database.
    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        let mut statement = tx.prepare_cached("SELECT COUNT(*) FROM proteus_identities")?;
        let count = statement.query_one([], |row| row.get::<_, u32>(0))?;
        Ok(count)
    }

    /// Use the transaction's interface to save this entity to the database
    async fn save(&self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        let count = <Self as EntityTransactionExt>::count(tx).await?;
        if count > 0 {
            return Err(CryptoKeystoreError::AlreadyExists("ProteusEntity"));
        }

        let mut statement = tx.prepare_cached("INSERT INTO proteus_identities (sk, pk) values (?, ?)")?;
        statement.execute([&self.sk, &self.pk])?;
        Ok(())
    }

    /// Use the transaction's inteface to delete this entity from the database.
    ///
    /// Returns `true` if at least one entity was deleted, or `false` if the id was not found in the database.
    async fn delete(tx: &Self::Transaction, _id: &()) -> CryptoKeystoreResult<bool> {
        let mut statement = tx.prepare_cached("DELETE FROM proteus_identities")?;
        let affected = statement.execute([])?;
        Ok(affected > 0)
    }
}

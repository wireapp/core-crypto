// Wire
// Copyright (C) 2022 Wire Swiss GmbH

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see http://www.gnu.org/licenses/.

import * as CoreCryptoFfiTypes from "./autogenerated/core_crypto_ffi";
import {
    openDatabase as _openDatabase,
    CoreCryptoFfi,
} from "./autogenerated/core_crypto_ffi";

import { CoreCryptoError } from "./autogenerated/core_crypto_ffi";

import { CoreCryptoContext } from "./CoreCryptoContext";

/**
 * Wrapper for the WASM-compiled version of CoreCrypto
 */
export class CoreCrypto extends CoreCryptoFfi {
    /** @internal */
    static instanceOf(obj: unknown): obj is CoreCryptoFfi {
        return super.instanceOf(obj);
    }

    constructor(database: CoreCryptoFfiTypes.Database) {
        super(database);
    }

    /**
     * Starts a new transaction in Core Crypto. If the callback succeeds, it will be committed,
     * otherwise, every operation performed with the context will be discarded.
     *
     * @param callback - The callback to execute within the transaction
     *
     * @returns the result of the callback will be returned from this call
     */
    async newTransaction<R>(
        callback: (ctx: CoreCryptoContext) => Promise<R>
    ): Promise<R> {
        let result!: R;
        let error: CoreCryptoError | Error | null = null;
        let needOuterRethrow = false;
        try {
            await super.transaction({
                execute: async (ctx: CoreCryptoFfiTypes.CoreCryptoContext) => {
                    try {
                        result = await callback(new CoreCryptoContext(ctx));
                    } catch (e) {
                        // We want to catch the error before it gets wrapped by core crypto.
                        if (CoreCryptoError.instanceOf(e)) {
                            error = e;
                        } else if (Error.isError(e)) {
                            error = e;
                        } else {
                            // Something unexpected was thrown
                            needOuterRethrow = true;
                        }
                        // This is to tell core crypto that there was an error inside the transaction.
                        throw e;
                    }
                },
            });
        } catch (e) {
            // We prefer the closure error if it's available since the transaction will just wrap and re-throw it.
            // If we caught an object of an unexpected type, we're rethrowing it as a wrapped `CoreCryptoError`.
            if (needOuterRethrow) {
                throw e;
            }
        }
        if (error !== null) {
            throw error;
        }
        return result;
    }

    /** @internal */
    async transaction(
        command: CoreCryptoFfiTypes.CoreCryptoCommand,
        asyncOpts_?: { signal: AbortSignal }
    ): Promise<void> {
        super.transaction(command, asyncOpts_);
    }
}

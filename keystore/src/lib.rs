#![doc = include_str!("../README.md")]
#![doc = include_str!("../../docs/KEYSTORE_IMPLEMENTATION.md")]

mod error;
pub use error::*;

pub mod connection;
pub use connection::{Connection, ConnectionType, DatabaseKey};
pub mod entities;
pub mod transaction;

pub(crate) mod mls;
pub use self::mls::CryptoKeystoreMls;
pub use self::mls::{deser, ser};

cfg_if::cfg_if! {
    if #[cfg(feature = "proteus-keystore")] {
        pub(crate) mod proteus;
        pub use self::proteus::CryptoKeystoreProteus;
    }
}
#[cfg(target_family = "wasm")]
pub use connection::keystore_v_1_0_0;

#[cfg(not(target_family = "wasm"))]
use sha2::{Digest, Sha256};

#[cfg(feature = "dummy-entity")]
pub mod dummy_entity {
    use crate::{
        CryptoKeystoreResult, MissingKeyErrorKind,
        entities::{Entity, EntityBase, EntityFindParams, StringEntityId},
        transaction::dynamic_dispatch::EntityId,
    };

    #[derive(Debug, Eq, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
    pub struct DummyStoreValue;
    #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
    #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
    impl EntityBase for DummyStoreValue {
        type ConnectionType = crate::connection::KeystoreDatabaseConnection;
        type AutoGeneratedFields = ();
        const COLLECTION_NAME: &'static str = "";

        fn to_missing_key_err_kind() -> MissingKeyErrorKind {
            MissingKeyErrorKind::PersistedMlsGroup
        }

        fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
            unimplemented!("Not implemented")
        }
    }

    #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
    #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
    impl Entity for DummyStoreValue {
        fn id_raw(&self) -> impl std::convert::AsRef<[u8]> {
            b""
        }

        async fn find_all(
            _conn: &mut Self::ConnectionType,
            _params: EntityFindParams,
        ) -> CryptoKeystoreResult<Vec<Self>> {
            Ok(vec![])
        }
        async fn find_one(_conn: &mut Self::ConnectionType, _id: &EntityId) -> CryptoKeystoreResult<Option<Self>> {
            Ok(Some(DummyStoreValue))
        }
        async fn find_many(conn: &mut Self::ConnectionType, ids: &[EntityId]) -> CryptoKeystoreResult<Vec<Self>> {
            // Default, inefficient & naive method
            let mut ret = Vec::with_capacity(ids.len());
            for id in ids {
                if let Some(entity) = Self::find_one(conn, id).await? {
                    ret.push(entity);
                }
            }

            Ok(ret)
        }
        async fn count(_conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<usize> {
            Ok(0)
        }

        #[cfg(target_family = "wasm")]
        fn encrypt(&mut self, _cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
            Ok(())
        }
        #[cfg(target_family = "wasm")]
        fn decrypt(&mut self, _cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
            Ok(())
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct DummyValue(Vec<u8>);

    impl From<&str> for DummyValue {
        fn from(id: &str) -> Self {
            DummyValue(format!("dummy value {id}").into_bytes())
        }
    }
}

/// Used to calculate ID hashes for some MlsEntities' SQLite tables (not used on wasm).
/// We only use sha256 on platforms where we use SQLite.
/// On wasm, we use IndexedDB, a key-value store, via the idb crate.
#[cfg(not(target_family = "wasm"))]
pub(crate) fn sha256(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

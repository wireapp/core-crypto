import { ccInit, setup, teardown } from "./utils";
import { afterEach, test, beforeEach, describe, expect } from "bun:test";
import {
    Ciphersuite,
    ciphersuiteDefault,
    ClientId,
    CredentialType,
} from "../../src/CoreCrypto";
import { credentialBasic } from "../../src/autogenerated/core_crypto_ffi";

beforeEach(async () => {
    await setup();
});

afterEach(async () => {
    await teardown();
});

describe("credentials", () => {
    test("basic credential can be created", async () => {
        const credential = credentialBasic(
            ciphersuiteDefault(),
            new ClientId(Buffer.from("any random client id here").buffer)
        );
        expect(credential.type()).toEqual(CredentialType.Basic);
        expect(credential.earliestValidity()).toEqual(0n);
    });

    test("credential can be added", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const ref = await cc.newTransaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        expect(ref).toBeDefined();
        expect(ref.type()).toEqual(CredentialType.Basic);
        // saving causes the earliest validity to be updated
        expect(ref.earliestValidity()).not.toEqual(0n);

        const allCredentials = await cc.newTransaction(async (ctx) => {
            return await ctx.getCredentials();
        });
        expect(allCredentials.length).toBe(1);
    });

    test("credential can be removed", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const credential = credentialBasic(ciphersuiteDefault(), clientId);

        const cc = await ccInit(clientId);

        const ref = await cc.newTransaction(async (ctx) => {
            return await ctx.addCredential(credential);
        });

        await cc.newTransaction(async (ctx) => {
            return await ctx.removeCredential(ref);
        });

        const allCredentials = await cc.newTransaction(async (ctx) => {
            return await ctx.getCredentials();
        });
        expect(allCredentials.length).toBe(0);
    });

    test("credentials can be searched", async () => {
        const clientId = new ClientId(
            Buffer.from("any random client id here").buffer
        );
        const ciphersuite1 = Ciphersuite.Mls128Dhkemp256Aes128gcmSha256P256;
        const credential1 = credentialBasic(ciphersuite1, clientId);

        const ciphersuite2 =
            Ciphersuite.Mls128Dhkemx25519Chacha20poly1305Sha256Ed25519;
        const credential2 = credentialBasic(ciphersuite2, clientId);

        const cc = await ccInit(clientId);

        await cc.newTransaction(async (ctx) => {
            await ctx.addCredential(credential1);
            await ctx.addCredential(credential2);
        });

        const results1 = await cc.newTransaction(async (ctx) => {
            return await ctx.getFilteredCredentials({
                ciphersuite: ciphersuite1,
            });
        });
        const results2 = await cc.newTransaction(async (ctx) => {
            return await ctx.getFilteredCredentials({
                ciphersuite: ciphersuite2,
            });
        });

        expect(results1.length).toBe(1);
        expect(results2.length).toBe(1);
        expect(results1[0]).not.toEqual(results2[0]);
    });
});

use core_crypto_keystore::{
    connection::FetchFromDatabase as _,
    entities::{EntityFindParams, StoredCredential, StoredSignatureKeypair},
};
use mls_crypto_provider::Database;
use openmls::prelude::Credential as MlsCredential;
use tls_codec::{Deserialize as _, Serialize as _};

use super::{Error, Result};
use crate::{Credential, CredentialRef, KeystoreError, mls::credential::keypairs};

/// Helper struct caching relevant data from the keystore.
///
/// This is generated by [`Credential::load_caches`]. It's only relevant when you want to
/// load multiple credentials at once. For single loads, prefer [`Credential::load`].
//
// We'd very much like it if in the future we could do filtering at the database level,
// obviating the requirement for this cache structure. See WPB-20839 and WPB-20844.
pub struct Caches {
    keypairs: Vec<StoredSignatureKeypair>,
    credentials: Vec<StoredCredential>,
}

impl Credential {
    /// Update all the fields that get updated by the DB in
    /// [`<StoredCredential as EntityTransactionExt>::pre_save`][core_crypto_keystore::entities::EntityTransactionExt::pre_save].
    fn update_from(&mut self, stored: StoredCredential) {
        self.earliest_validity = stored.created_at;
    }

    /// Persist this credential into the database.
    ///
    /// Returns a reference which is stable over time and across the FFI boundary.
    pub async fn save(&mut self, database: &Database) -> Result<CredentialRef> {
        keypairs::store(database, self.client_id(), &self.signature_key_pair).await?;

        let credential_data = self
            .mls_credential
            .tls_serialize_detached()
            .map_err(Error::tls_serialize("credential"))?;

        let stored_credential = database
            .save(StoredCredential {
                id: self.client_id().to_owned().into_inner(),
                credential: credential_data,
                created_at: 0,
            })
            .await
            .map_err(KeystoreError::wrap("saving credential"))?;

        self.update_from(stored_credential);

        Ok(CredentialRef::new(
            self.client_id().to_owned(),
            self.mls_credential.credential_type(),
            self.signature_key_pair.signature_scheme(),
        ))
    }

    /// Load this credential from the database.
    ///
    /// Note that this does not attach the credential to any Session; it just does the data manipulation.
    ///
    /// The database schema currently permits multiple credentials to exist simultaneously which match a given credential ref.
    /// Therefore, this function returns all of them, ordered by `earliest_validity`.
    ///
    /// Due to database limitations we currently cannot efficiently retrieve only those keypairs of interest;
    /// if you are going to be loading several references in a row, it is more efficient to first fetch all
    /// stored keypairs with [`Self::load_caches`] and then call [`Self::load_with_caches`].
    pub async fn load(database: &Database, credential_ref: &CredentialRef) -> Result<Vec<Self>> {
        let cache = Self::load_caches(database).await?;
        Self::load_with_caches(credential_ref, &cache).await?.collect()
    }

    /// Helper to prefetch relevant keypairs when loading multiple credentials at a time.
    ///
    /// Only useful when preparing to call [`Self::load_with_caches`] multiple times.
    /// For loading a single credential, prefer [`Self::load`].
    pub async fn load_caches(database: &Database) -> Result<Caches> {
        let keypairs = keypairs::load_all(database).await?;
        let mut credentials = database
            .find_all::<StoredCredential>(EntityFindParams::default())
            .await
            .map_err(KeystoreError::wrap("finding all mls credentials"))?;
        credentials.sort_by_key(|credential| credential.created_at);
        Ok(Caches { keypairs, credentials })
    }

    /// Load this credential from the database.
    ///
    /// Note that this does not attach the credential to any Session; it just does the data manipulation.
    ///
    /// The database schema currently permits multiple credentials to exist simultaneously which match a given credential ref.
    /// Therefore, this function returns a possibly-empty iterator over all of them, ordered by `earliest_validity`.
    ///
    /// If you are only loading a single credential, it may be simpler to call [`Self::load`].
    pub async fn load_with_caches<'cache, 'cref>(
        credential_ref: &'cref CredentialRef,
        Caches { keypairs, credentials }: &'cache Caches,
    ) -> Result<impl 'cache + Iterator<Item = Result<Self>>>
    where
        'cref: 'cache,
    {
        let signature_key_pair =
            keypairs::find_matching(keypairs, credential_ref.client_id(), credential_ref.signature_scheme())
                .await?
                .ok_or(Error::KeypairNotFound)?;

        let iter = credentials
            .iter()
            // this is the only check we can currently do at the DB level: match the client id
            .filter(|stored_credential| stored_credential.id == credential_ref.client_id().as_slice())
            // from here we can at least deserialize the credential
            .map(move |stored_credential| {
                let mls_credential = MlsCredential::tls_deserialize(&mut stored_credential.credential.as_slice())
                    .map_err(Error::tls_deserialize("mls credential"))?;
                let earliest_validity = stored_credential.created_at;
                Ok(Self {
                    signature_key_pair: signature_key_pair.clone(),
                    mls_credential,
                    earliest_validity,
                })
            })
            // after deserialization, we can filter out any results which do not match the conditions in the credential ref
            // but pass through any errors
            .filter(|credential_result| {
                credential_result
                    .as_ref()
                    .map(|credential| {
                        credential.signature_key_pair.signature_scheme() == credential_ref.signature_scheme()
                            && credential.mls_credential.credential_type() == credential_ref.r#type()
                    })
                    .unwrap_or(true)
            })
            // we also need to ensure that the credential validates
            .map(|credential_result| {
                credential_result.and_then(|credential| {
                    Self::validate_mls_credential(
                        &credential.mls_credential,
                        credential_ref.client_id(),
                        &credential.signature_key_pair,
                    )?;
                    Ok(credential)
                })
            });

        Ok(iter)
    }
}

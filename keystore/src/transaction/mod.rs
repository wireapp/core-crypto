use std::{
    any::TypeId,
    borrow::Cow,
    collections::{HashMap, HashSet, hash_map::Entry},
    iter::Cloned,
    ops::Deref,
    sync::{Arc, LazyLock, OnceLock},
};

use async_lock::{
    RwLock, RwLockReadGuard, RwLockReadGuardArc, RwLockUpgradableReadGuard, RwLockUpgradableReadGuardArc,
    RwLockWriteGuardArc, SemaphoreGuardArc,
};
use itertools::Itertools;

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult,
    connection::{Database, KeystoreDatabaseConnection},
    entities::{MlsPendingMessage, PersistedMlsGroup},
    traits::{
        BorrowPrimaryKey, Entity, EntityBase as _, EntityDatabaseMutation, EntityDeleteBorrowed, KeyType,
        SearchableEntity,
    },
    transaction::dynamic_dispatch::{EntityId, EntityType},
};

pub(crate) mod dynamic_dispatch;

struct EntityReadRef<E>(Arc<RwLock<Option<E>>>);

impl<E> EntityReadRef<E> {
    pub(crate) async fn guard(&self, mut f: impl AsyncFnMut(&E)) {
        let guard = self.0.as_ref().read().await;
        let e = guard.as_ref().expect("this is always Some");
        f(&e).await
    }
}

/// table: primary key -> entity reference
///
/// The inner value is an option: `None` represents a deletion, `Some()` represents an upsert. Accordingly, those
/// operations will be executed when the transaction is finished.
pub(crate) type InMemoryTable<E> = Arc<RwLock<HashMap<Vec<u8>, Arc<RwLock<Option<E>>>>>>;
pub(crate) type InMemoryTableGuard<E> = RwLockUpgradableReadGuardArc<HashMap<Vec<u8>, Arc<RwLock<Option<E>>>>>;

/// This represents a transaction, where all operations will be done in memory and committed at the
/// end
#[derive(Debug, Clone)]
pub(crate) struct KeystoreTransaction {
    _semaphore_guard: Arc<SemaphoreGuardArc>,
}

impl KeystoreTransaction {
    /// Instantiate a new transaction.
    ///
    /// Requires a semaphore guard to ensure that only one exists at a time.
    pub(crate) async fn new(semaphore_guard: SemaphoreGuardArc) -> CryptoKeystoreResult<Self> {
        Ok(Self {
            _semaphore_guard: Arc::new(semaphore_guard),
        })
    }

    /// Save an entity into this transaction.
    ///
    /// This is a multi-step process:
    ///
    /// - Adjust the entity by calling its [`pre_save()`][Entity::pre_save] method.
    /// - Store the entity in an internal map.
    ///   - Remove the entity from the set of deleted entities, if it was there.
    /// - On [`Self::commit`], actually persist the entity into the supplied database.
    pub(crate) async fn save<'a, E>(&self, mut entity: E) -> CryptoKeystoreResult<E::AutoGeneratedFields>
    where
        E: Entity<ConnectionType = KeystoreDatabaseConnection> + EntityDatabaseMutation<'a> + Send + Sync,
    {
        let auto_generated_fields = entity.pre_save().await?;

        self.delete_or_save(entity.primary_key().bytes(), Some(entity)).await?;

        Ok(auto_generated_fields)
    }

    async fn remove_by_entity_id<'a, E>(&self, id: Cow<'_, [u8]>) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        // rm this entity from the set of added/modified items
        // it might never touch the real db at all
        // start by adding the entity
        self.delete_or_save::<E>(id, None).await
    }

    async fn delete_or_save<'a, E>(&self, id: Cow<'_, [u8]>, entity: Option<E>) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        let table = E::get_in_memory_table();

        if let Some(entity_lock) = table.get(&id.to_vec()).cloned() {
            let mut guard = entity_lock.write().await;
            *guard = entity;
        } else {
            let entry = Arc::new(RwLock::new(entity));
            let mut table = RwLockUpgradableReadGuardArc::upgrade(table).await;
            table.insert(id.to_vec(), entry);
        }

        Ok(())
    }

    /// Remove an entity by its primary key.
    ///
    /// Where the primary key has a distinct borrowed form, consider [`Self::remove_borrowed`].
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove<'a, E>(&self, id: &E::PrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: Entity + EntityDatabaseMutation<'a>,
    {
        self.remove_by_entity_id::<E>(id.bytes()).await
    }

    /// Remove an entity by the borrowed form of its primary key.
    ///
    /// Note that this doesn't return whether or not anything was actually removed because
    /// that won't happen until the transaction is committed.
    pub(crate) async fn remove_borrowed<'a, E>(&self, id: &E::BorrowedPrimaryKey) -> CryptoKeystoreResult<()>
    where
        E: EntityDeleteBorrowed<'a> + BorrowPrimaryKey,
    {
        self.remove_by_entity_id::<E>(id.to_owned().bytes()).await
    }

    pub(crate) async fn child_groups(
        &self,
        entity: PersistedMlsGroup,
        persisted_records: impl IntoIterator<Item = PersistedMlsGroup>,
    ) -> Vec<RwLockReadGuardArc<Option<PersistedMlsGroup>>> {
        self.extend_cache::<PersistedMlsGroup>(persisted_records).await;

        self.find_all_in_cache::<PersistedMlsGroup>()
            .await
            .into_iter()
            .filter(|maybe_child| {
                maybe_child
                    .as_ref()
                    .and_then(|child| child.parent_id.as_deref())
                    .map(|pid| pid == entity.borrow_primary_key().bytes().as_ref())
                    .unwrap_or_default()
            })
            .collect()
    }

    pub(crate) async fn remove_pending_messages_by_conversation_id(&self, conversation_id: impl AsRef<[u8]> + Send) {
        let conversation_id = conversation_id.as_ref();
        let pending_messages_table = MlsPendingMessage::get_in_memory_table();
        for (_, pending_message_lock) in pending_messages_table.iter() {
            let pending_message_guard = pending_message_lock.upgradable_read().await;

            if let Some(pending_message) = pending_message_guard.as_ref()
                && pending_message.foreign_id == conversation_id
            {
                // upgrade lock
                let mut pending_message = RwLockUpgradableReadGuard::upgrade(pending_message_guard).await;
                *pending_message = None;
            }
        }
    }

    pub(crate) async fn find_pending_messages_by_conversation_id(
        &self,
        conversation_id: &[u8],
        persisted_records: impl IntoIterator<Item = MlsPendingMessage>,
    ) -> Vec<RwLockReadGuardArc<Option<MlsPendingMessage>>> {
        self.extend_cache::<MlsPendingMessage>(persisted_records).await;

        self.find_all_in_cache::<MlsPendingMessage>()
            .await
            .into_iter()
            .filter(|pending_message| {
                pending_message
                    .as_ref()
                    .map(|id| id.foreign_id == conversation_id)
                    .unwrap_or_default()
            })
            .collect()
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get<'a, E>(&'a self, id: &E::PrimaryKey) -> Option<RwLockReadGuardArc<Option<E>>>
    where
        E: Entity + Send + Sync,
    {
        let table = E::get_in_memory_table();
        let id = id.bytes();

        if let Some(entity) = table.get(id.as_ref()).cloned() {
            Some(entity.read_arc().await)
        } else {
            None
        }
    }

    /// The result of this function will have different contents for different scenarios:
    /// * `Some(Some(E))` - the transaction cache contains the record
    /// * `Some(None)` - the deletion of the record has been cached
    /// * `None` - there is no information about the record in the cache
    pub(crate) async fn get_borrowed<E>(&self, id: &E::BorrowedPrimaryKey) -> Option<RwLockReadGuardArc<Option<E>>>
    where
        E: Entity + BorrowPrimaryKey + Send + Sync,
        <E as BorrowPrimaryKey>::BorrowedPrimaryKey: KeyType,
    {
        let table = E::get_in_memory_table();
        let id = id.bytes();

        if let Some(entity) = table.get(id.as_ref()).cloned() {
            Some(entity.read_arc().await)
        } else {
            None
        }
    }

    async fn find_all_in_cache<E>(&self) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Entity + Send + Sync,
    {
        let table = E::get_in_memory_table();
        let mut records = Vec::with_capacity(table.values().len());
        for record in table.values().cloned() {
            records.push(record.read_arc().await);
        }
        records
    }

    async fn search_in_cache<E, SearchKey>(&self, search_key: &SearchKey) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Entity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        self.find_all_in_cache::<E>()
            .await
            .into_iter()
            .map(|record| record)
            .filter(|record| record.as_ref().is_some_and(|e| e.matches(search_key)))
            .collect()
    }

    pub(crate) async fn find_all<E>(&self, persisted_records: Vec<E>) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Clone + Entity + Send + Sync,
    {
        self.extend_cache(persisted_records).await;
        self.find_all_in_cache::<E>().await
    }

    pub(crate) async fn search<E, SearchKey>(
        &self,
        persisted_records: Vec<E>,
        search_key: &SearchKey,
    ) -> Vec<RwLockReadGuardArc<Option<E>>>
    where
        E: Clone + Entity + SearchableEntity<SearchKey> + Send + Sync,
        SearchKey: KeyType,
    {
        self.extend_cache(persisted_records);
        self.search_in_cache(search_key).await
    }

    /// Put each of the given items into the cache if the cache doesn't contain its id yet.
    async fn extend_cache<'a, E>(&self, records: impl IntoIterator<Item = E>)
    where
        E: Entity,
    {
        let table = E::get_in_memory_table();
        let mut table = RwLockUpgradableReadGuardArc::upgrade(table).await;

        for record in records {
            let record_id = record.primary_key().bytes().to_vec();
            if !table.contains_key(&record_id) {
                table.insert(record_id, Arc::new(RwLock::new(Some(record))));
            }
        }
    }

    /// Persists all the operations in the database. It will effectively open a transaction
    /// internally, perform all the buffered operations and commit.
    pub(crate) async fn commit(&self, db: &Database) -> Result<(), CryptoKeystoreError> {
        let conn = db.conn().await?;
        let mut conn = conn.conn().await;

        let cache = self.cache.read().await;
        let deleted_ids = self.deleted.read().await;

        let table_names_with_deletion = deleted_ids.iter().map(|entity_id| entity_id.collection_name());
        let table_names_with_save = cache
            .values()
            .flat_map(|table| table.keys())
            .map(|entity_id| entity_id.collection_name());
        let mut tables = table_names_with_deletion
            .chain(table_names_with_save)
            .collect::<Vec<_>>();

        if tables.is_empty() {
            log::debug!("Empty transaction was committed.");
            return Ok(());
        }

        tables.sort_unstable();
        tables.dedup();

        // open a database transaction
        #[cfg(target_family = "wasm")]
        let tx = conn.new_transaction(&tables).await?;
        #[cfg(not(target_family = "wasm"))]
        let tx = conn.transaction()?.into();

        for entity in cache.values().flat_map(|table| table.values()) {
            entity.execute_save(&tx).await?;
        }

        for deleted_id in deleted_ids.iter() {
            deleted_id.execute_delete(&tx).await?;
        }

        // and commit everything
        tx.commit_tx().await?;

        // TODO: purge all hashmaps after committing

        Ok(())
    }
}

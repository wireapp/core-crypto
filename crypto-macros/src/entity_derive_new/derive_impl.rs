use proc_macro2::TokenStream;
use quote::quote;

use crate::entity_derive_new::Entity;

impl quote::ToTokens for Entity {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        tokens.extend(self.impl_entity_base());
        tokens.extend(self.impl_entity_generic());
        tokens.extend(self.impl_entity_wasm());
        tokens.extend(self.impl_borrow_primary_key());
    }
}

impl Entity {
    /// `impl EntityBase for MyEntity`
    fn impl_entity_base(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            ..
        } = self;

        // Identical for both wasm and non-wasm
        quote! {
            #[cfg_attr(target_family = "wasm", async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), async_trait::async_trait)]
            impl crate::traits::EntityBase for #struct_name {
                type ConnectionType = crate::connection::KeystoreDatabaseConnection;
                type AutoGeneratedFields = ();
                const COLLECTION_NAME: &'static str = #collection_name;

                fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
                    crate::transaction::dynamic_dispatch::Entity::#struct_name(self)
                }
            }
        }
    }

    /// `#[cfg(not(target_family = "wasm"))] impl Entity for MyEntity`
    fn impl_entity_generic(&self) -> TokenStream {
        let Self {
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let primary_key = id_column.column_type.owned();
        let id_field_name = &id_column.field_name;

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        quote! {
            #[cfg(not(target_family = "wasm"))]
            #[::async_trait::async_trait]
            impl crate::traits::Entity for #struct_name {
                type PrimaryKey = #primary_key;

                fn primary_key(&self) -> #primary_key {
                    self.#id_field_name.clone()
                }

                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    <Self as crate::traits::BorrowPrimaryKey>::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    crate::entities::platform::count_helper::<Self>(conn).await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    crate::entities::platform::load_all_helper::<Self, _>(conn, |row| {
                        Ok(Self {
                            #( #field_assignments, )*
                        })
                    }).await
                }
            }
        }
    }

    /// `#[cfg(target_family = "wasm")] impl Entity for MyEntity`
    fn impl_entity_wasm(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            ..
        } = self;

        let primary_key = id_column.column_type.owned();
        let id_field_name = &id_column.field_name;

        quote! {
            #[cfg(target_family = "wasm")]
            #[::async_trait::async_trait(?Send)]
            impl crate::traits::Entity for #struct_name {
                type PrimaryKey = #primary_key;

                fn primary_key(&self) -> #primary_key {
                    self.#id_field_name.clone()
                }

                async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> crate::CryptoKeystoreResult<Option<Self>> {
                    Self::get_borrowed(conn, key).await
                }

                async fn count(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<u32> {
                    conn.storage().count(#collection_name).await
                }

                async fn load_all(conn: &mut Self::ConnectionType) -> crate::CryptoKeystoreResult<Vec<Self>> {
                    conn.storage().get_all(#collection_name).await
                }
            }
        }
    }

    /// `impl BorrowPrimaryKey for MyEntity`
    fn impl_borrow_primary_key(&self) -> TokenStream {
        let Self {
            collection_name,
            struct_name,
            id_column,
            other_columns,
            ..
        } = self;

        let borrowed_primary_key = id_column.column_type.borrowed();
        let pk_field_name = &id_column.field_name;
        let pk_column_name = id_column
            .column_name
            .clone()
            .unwrap_or_else(|| id_column.field_name.to_string());

        let field_assignments = std::iter::once(id_column.field_assignment())
            .chain(other_columns.iter().map(|column| column.field_assignment()));

        quote! {
            #[cfg_attr(target_family = "wasm", ::async_trait::async_trait(?Send))]
            #[cfg_attr(not(target_family = "wasm"), ::async_trait::async_trait)]
            impl crate::traits::BorrowPrimaryKey for #struct_name {
                type BorrowedPrimaryKey = #borrowed_primary_key;

                fn borrow_primary_key(&self) -> &Self::BorrowedPrimaryKey {
                    &self.#pk_field_name
                }

                async fn get_borrowed<Q>(conn: &mut Self::ConnectionType, key: &Q) -> crate::CryptoKeystoreResult<Option<Self>>
                where
                    Self::PrimaryKey: std::borrow::Borrow<Q>,
                    Q: crate::traits::KeyType,
                {
                    #[cfg(target_family = "wasm")]
                    {
                        conn.storage().get(#collection_name, key.bytes().as_ref()).await
                    }

                    #[cfg(not(target_family = "wasm"))]
                    {
                        crate::entities::platform::get_helper::<Self, _>(conn, #pk_column_name, key.bytes().as_ref(), |row| {
                            Ok(Self {
                                #( #field_assignments, )*
                            })
                        }).await
                    }
                }
            }
        }
    }
}

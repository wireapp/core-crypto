use web_time::SystemTime;
use zeroize::ZeroizeOnDrop;

use crate::{
    CryptoKeystoreError, CryptoKeystoreResult,
    connection::{KeystoreDatabaseConnection, TransactionWrapper},
    migrations::V5Credential,
    traits::{
        DecryptData as _, Decryptable, Decrypting, EncryptData as _, Encrypting, Entity, EntityBase,
        EntityDatabaseMutation, PrimaryKey,
    },
};

impl EntityBase for V5Credential {
    type ConnectionType = KeystoreDatabaseConnection;
    type AutoGeneratedFields = u64;
    const COLLECTION_NAME: &'static str = "mls_credentials";

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        // We could just add a variant to the enum, but we're not going to need it.
        unimplemented!("V5 credential is not used in transactions")
    }
}

impl PrimaryKey for V5Credential {
    type PrimaryKey = Vec<u8>;

    fn primary_key(&self) -> Self::PrimaryKey {
        self.id.clone()
    }
}

#[async_trait::async_trait(?Send)]
impl Entity for V5Credential {
    async fn get(conn: &mut Self::ConnectionType, key: &Self::PrimaryKey) -> CryptoKeystoreResult<Option<Self>> {
        conn.storage().new_get(key).await
    }

    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<u32> {
        conn.storage().new_count::<Self>().await
    }

    async fn load_all(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<Vec<Self>> {
        conn.storage().new_get_all::<Self>().await
    }
}

#[async_trait::async_trait(?Send)]
impl<'a> EntityDatabaseMutation<'a> for V5Credential {
    type Transaction = TransactionWrapper<'a>;

    async fn pre_save(&mut self) -> CryptoKeystoreResult<Self::AutoGeneratedFields> {
        let now = SystemTime::now();
        let created_at = now
            .duration_since(SystemTime::UNIX_EPOCH)
            .map_err(|_| CryptoKeystoreError::TimestampError)?
            .as_secs();
        self.created_at = created_at;
        Ok(created_at)
    }

    async fn save(&'a self, tx: &Self::Transaction) -> CryptoKeystoreResult<()> {
        tx.new_save(self).await
    }

    async fn count(tx: &Self::Transaction) -> CryptoKeystoreResult<u32> {
        tx.new_count::<Self>().await
    }

    async fn delete(tx: &Self::Transaction, id: &Self::PrimaryKey) -> CryptoKeystoreResult<bool> {
        tx.new_delete::<Self>(id).await
    }
}

#[derive(ZeroizeOnDrop, serde::Serialize, serde::Deserialize)]
pub(crate) struct EncryptedV5Credential {
    pub id: Vec<u8>,
    pub credential: Vec<u8>,
    pub created_at: u64,
}

impl Decrypting<'static> for EncryptedV5Credential {
    type DecryptedForm = V5Credential;

    fn decrypt(mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::DecryptedForm> {
        let id = std::mem::take(&mut self.id);
        let created_at = self.created_at;

        let credential = V5Credential::decrypt_data(cipher, &id, &self.credential)?;

        Ok(V5Credential {
            id,
            credential,
            created_at,
        })
    }
}

impl Decryptable<'static> for V5Credential {
    type DecryptableFrom = EncryptedV5Credential;
}

impl<'a> Encrypting<'a> for V5Credential {
    type EncryptedForm = EncryptedV5Credential;

    fn encrypt(&'a self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<Self::EncryptedForm> {
        let id = self.id.clone();
        let created_at = self.created_at;

        let credential = self.encrypt_data(cipher, &self.credential)?;

        Ok(EncryptedV5Credential {
            id,
            credential,
            created_at,
        })
    }
}

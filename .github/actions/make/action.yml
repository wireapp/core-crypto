name: Fetch or make an artifact
description: Fetch the newest artifact (on the current branch or on main) with a given key.
  If it doesn't exist, run the given command and upload it.
inputs:
  key:
    description: The artifact key
    required: true
  make-rule:
    description: The GNU make rule which produces the artifact
    required: true
  target-path:
    description: The relative path of the final artifact(s)
    required: true
  gh-token:
    required: true

runs:
  using: composite
  steps:
    - name: compute artifact key
      shell: bash -euo pipefail {0}
      id: compute-key
      run: |
        files_hash=$(make "${{ inputs.make-rule }}"-hash-deps)
        echo "key=${{ inputs.key }}-$files_hash" >> "$GITHUB_OUTPUT"

    - name: Download artifact
      run: |
        branch="${{ github.head_ref || github.ref_name }}"

        runs_current_branch=$(gh run list --branch "$branch" --limit 10 -w bindings.yml --json databaseId | jq '.[].databaseId')
        runs_main=$(gh run list --branch main --limit 10 -w bindings.yml --json databaseId | jq '.[].databaseId')

        # Prioritize current branch over main
        runs=$(printf "%s\n%s\n" "$runs_current_branch" "$runs_main")

        artifact_name="${{ steps.compute-key.outputs.key }}"

        echo "found=false" >> $GITHUB_ENV
        echo "found_in_this_run=false" >> $GITHUB_ENV

        # For each run in the sorted list of run ids, try downloading the artifact
        # with the given name.
        for run_id in $runs; do
          if gh run download "$run_id" -n "$artifact_name" >/dev/null 2>&1; then
            echo "Downloaded artifact $artifact_name from run with id: $run_id"
            echo "found=true" >> $GITHUB_ENV
            if [ "$run_id" = "${{ github.run_id }}" ]; then
              echo "found_in_this_run=true" >> $GITHUB_ENV
            fi
            exit 0
          fi
        done

        echo "No artifact '$artifact_name' found." >&2
      env:
        GITHUB_TOKEN: ${{ inputs.gh-token }}
      shell: bash -euo pipefail {0}

    - name: Unpack and touch downloaded files to update timestamps
      if: env.found == 'true'
      run: |
        tar -xzf artifact.tar.gz
        # This is necessary because the github checkout action doesn't preserve
        # timestamps on checked out files.
        paths="${{ inputs.target-path }}"
        for dir in $paths; do
          touch "$dir"
        done
      shell: bash -leo pipefail {0}

    - name: Run make ${{ inputs.make-rule }} if needed
      if: env.found != 'true'
      run: make ${{ inputs.make-rule }}
      shell: bash -leo pipefail {0}

    - name: Prepare artifact
      run: |
        mkdir -p .stamps
        printf '%s\n' "${{ inputs.target-path }}" | tar -czf artifact.tar.gz -T - .stamps
      shell: bash -leo pipefail {0}

    - name: Upload artifact if it doesn't exist for this workflow run
      if: env.found_in_this_run != 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.compute-key.outputs.key }}
        path: artifact.tar.gz

    - name: Cleanup
      run: |
        rm artifact.tar.gz
      shell: bash -leo pipefail {0}

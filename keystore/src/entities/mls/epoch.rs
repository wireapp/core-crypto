use mls_rs_core::group::EpochRecord as MlsRsEpoch;
#[cfg(not(target_family = "wasm"))]
use rusqlite::{OptionalExtension as _, params};
use zeroize::ZeroizeOnDrop;

use crate::CryptoKeystoreResult;
use crate::MissingKeyErrorKind;
use crate::connection::KeystoreDatabaseConnection;
use crate::connection::TransactionWrapper;
use crate::entities::Entity;
use crate::entities::EntityBase;
use crate::entities::EntityFindParams;
use crate::transaction::dynamic_dispatch::EntityId;

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, ZeroizeOnDrop)]
pub struct Epoch {
    pub(crate) group_id: Vec<u8>,
    pub(crate) epoch_id: u64,
    pub(crate) epoch_data: Vec<u8>,
}

impl From<(Vec<u8>, MlsRsEpoch)> for Epoch {
    fn from(value: (Vec<u8>, MlsRsEpoch)) -> Self {
        Self {
            group_id: value.0,
            epoch_id: value.1.id,
            epoch_data: value.1.data,
        }
    }
}

impl From<Epoch> for (Vec<u8>, MlsRsEpoch) {
    fn from(value: Epoch) -> Self {
        (
            value.group_id.clone(),
            MlsRsEpoch {
                id: value.epoch_id,
                data: value.epoch_data.clone(),
            },
        )
    }
}

#[async_trait::async_trait]
impl EntityBase for Epoch {
    type ConnectionType = KeystoreDatabaseConnection;

    type AutoGeneratedFields = ();

    const COLLECTION_NAME: &'static str = "epochs";

    fn to_missing_key_err_kind() -> MissingKeyErrorKind {
        MissingKeyErrorKind::Epoch
    }

    fn to_transaction_entity(self) -> crate::transaction::dynamic_dispatch::Entity {
        crate::transaction::dynamic_dispatch::Entity::Epoch(self)
    }
}

#[async_trait::async_trait]
// #[async_trait::async_trait(?Send)]
impl Entity for Epoch {
    fn id_raw(&self) -> impl AsRef<[u8]> {
        self.merge_key()
    }

    async fn find_all(conn: &mut Self::ConnectionType, params: EntityFindParams) -> CryptoKeystoreResult<Vec<Self>> {
        todo!()
    }

    async fn find_one(conn: &mut Self::ConnectionType, id: &EntityId) -> CryptoKeystoreResult<Option<Self>> {
        todo!()
    }

    fn encrypt(&mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        todo!()
    }

    fn decrypt(&mut self, cipher: &aes_gcm::Aes256Gcm) -> CryptoKeystoreResult<()> {
        todo!()
    }

    async fn count(conn: &mut Self::ConnectionType) -> CryptoKeystoreResult<usize> {
        todo!()
    }
}

impl Epoch {
    pub(crate) fn merge_key(&self) -> Vec<u8> {
        Self::to_merge_key(&self.group_id, self.epoch_id)
    }

    pub(crate) fn to_merge_key(group_id: &[u8], epoch_id: u64) -> Vec<u8> {
        group_id.iter().copied().chain(epoch_id.to_le_bytes()).collect()
    }

    #[cfg(not(target_family = "wasm"))]
    pub(crate) async fn find_one(
        connection: &mut <Self as EntityBase>::ConnectionType,
        group_id: &[u8],
        epoch_id: u64,
    ) -> CryptoKeystoreResult<Option<Self>> {
        let connection = connection.conn().await;
        connection
            .query_row(
                &format!(
                    "SELECT epoch_data FROM {} where group_id = ? AND epoch_id = ?",
                    Self::COLLECTION_NAME
                ),
                params![group_id, epoch_id],
                |row| row.get::<_, Vec<u8>>(0),
            )
            .optional()
            .map(|option| {
                option.map(|epoch_data| Self {
                    group_id: group_id.to_vec(),
                    epoch_id,
                    epoch_data,
                })
            })
            .map_err(Into::into)
    }

    #[cfg(not(target_family = "wasm"))]
    pub(crate) async fn save(&self, transaction: &TransactionWrapper<'_>) -> CryptoKeystoreResult<()> {
        transaction
            .execute(
                &format!(
                    "INSERT INTO {} (group_id, epoch_id, epoch_data) VALUES (?, ?, ?) ON CONFLICT(group_id,epoch_id) DO UPDATE SET epoch_data=excluded.epoch_data",
                    Self::COLLECTION_NAME
                ),
                params![self.group_id, self.epoch_id, self.epoch_data],
            )
            .map(|_| ())
            .map_err(Into::into)
    }

    #[cfg(target_family = "wasm")]
    pub(crate) async fn save(&self, transaction: &TransactionWrapper<'_>) -> CryptoKeystoreResult<()> {
        todo!()
    }

    /// Delete all epochs of the group with the provided ID whose id is lower (i.e., older) than or equal
    /// to the provided epoch id.
    #[cfg(not(target_family = "wasm"))]
    pub(crate) async fn delete_by_id_less_equal(
        transaction: &TransactionWrapper<'_>,
        group_id: &[u8],
        epoch_id: u64,
    ) -> CryptoKeystoreResult<()> {
        transaction
            .execute(
                &format!(
                    "DELETE FROM {} WHERE group_id = ? AND epoch_id <= ?",
                    Self::COLLECTION_NAME
                ),
                params![group_id, epoch_id],
            )
            .map(|_| ())
            .map_err(Into::into)
    }

    /// Delete all epochs of the group with the provided ID whose id is lower (i.e., older) than or equal
    /// to the provided epoch id.
    #[cfg(target_family = "wasm")]
    pub(crate) async fn delete_by_id_less_equal(
        transaction: &TransactionWrapper<'_>,
        group_id: &[u8],
        epoch_id: u64,
    ) -> CryptoKeystoreResult<()> {
        todo!()
    }

    /// Delete all epochs of the group.
    /// Only needed for wasm, used for the manual ON DELETE CASCADE equivalent.
    #[cfg(target_family = "wasm")]
    pub(crate) async fn delete_by_group_id(
        transaction: &TransactionWrapper<'_>,
        group_id: &[u8],
    ) -> CryptoKeystoreResult<()> {
        todo!()
    }

    #[cfg(not(target_family = "wasm"))]
    pub(crate) async fn max_id(
        connection: &mut <Self as EntityBase>::ConnectionType,
        group_id: &[u8],
    ) -> CryptoKeystoreResult<Option<u64>> {
        let connection = connection.conn().await;

        connection
            .query_row(
                &format!("SELECT MAX(epoch_id) FROM {} WHERE group_id = ?", Self::COLLECTION_NAME),
                params![group_id],
                |row| row.get::<_, Option<u64>>(0),
            )
            .map_err(Into::into)
    }

    #[cfg(target_family = "wasm")]
    pub(crate) async fn max_id(
        connection: &mut <Self as EntityBase>::ConnectionType,
        group_id: &[u8],
    ) -> CryptoKeystoreResult<Option<u64>> {
        todo!()
    }
}
